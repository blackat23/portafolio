{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Portafolio de Antonio Mart\u00ednez","text":"<p>Mart\u00ednez</p> <p>\u00a1Bienvenido!  Este portafolio recopila proyectos, notas de clase y tutoriales relacionados con microcontroladores, sistemas embebidos e inteligencia artificial.</p> <p>En el men\u00fa lateral encontrar\u00e1s: - Proyectos destacados   - Tutoriales pr\u00e1cticos paso a paso - Referencias y enlaces \u00fatiles</p>"},{"location":"#sobre-mi","title":"Sobre m\u00ed","text":"<p>Soy estudiante de Ingenier\u00eda Mecatr\u00f3nica interesado en: - Microcontroladores y sistemas embebidos - Inteligencia artificial aplicada (visi\u00f3n por computadora, ciberseguridad) - Desarrollo de software y hardware para IoT  </p> <p>Habilidades t\u00e9cnicas: - Programaci\u00f3n: C/C++, Python, JavaScript - Electr\u00f3nica: dise\u00f1o de circuitos, sensores, actuadores - Herramientas: Git, AWS, SolidWorks, Arduino IDE, CATIA V5R21  </p> <p>Objetivos profesionales: Seguir desarrollando proyectos que combinen IA y sistemas embebidos, y eventualmente escalar mi startup tecnol\u00f3gica.</p>"},{"location":"analisis_cafeteras/","title":"An\u00e1lisis sobre las cafeteras de c\u00e1psulas","text":""},{"location":"analisis_cafeteras/#cafe-en-capsulas","title":"Caf\u00e9 en C\u00e1psulas","text":"<p>En esta presentaci\u00f3n exploraremos la evoluci\u00f3n y el impacto de las cafeteras de c\u00e1psulas. Revisaremos su origen hist\u00f3rico, el modelo de negocio que las hizo exitosas y c\u00f3mo han transformado los h\u00e1bitos de consumo de caf\u00e9 en hogares y oficinas. Tambi\u00e9n analizaremos sus principales ventajas y desventajas, los avances tecnol\u00f3gicos m\u00e1s recientes, y su penetraci\u00f3n en el mercado global. Finalmente, cerraremos con una reflexi\u00f3n sobre los retos que enfrenta este sistema, especialmente en t\u00e9rminos de sostenibilidad y costos, para entender por qu\u00e9 se ha convertido en un fen\u00f3meno tan relevante en la cultura del caf\u00e9. Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"controladores/","title":"Comparativa de Microcontroladores","text":"Perif\u00e9ricos, Memoria, Ecosistema, Costos, Arquitectura y Velocidad de Trabajo"},{"location":"controladores/#informacion","title":"Informacion","text":"<ul> <li>Nombre del proyecto: Comparativa de Microcontroladores</li> <li>Equipo / Autor(es): Antonio Mart\u00ednez</li> <li>Curso / Asignatura: Sistemas Embebidos</li> <li>Fecha: 23/08/2025</li> <li>Descripci\u00f3n breve: An\u00e1lisis comparativo de microcontroladores de distintas marcas considerando perif\u00e9ricos, memoria, ecosistema, costos, arquitectura y velocidad de trabajo.</li> </ul>"},{"location":"controladores/#introducion","title":"Introducion","text":""},{"location":"controladores/#sobre-los-microcontroladores","title":"Sobre los microcontroladores:","text":"<p>En el desarrollo de sistemas embebidos y proyectos electr\u00f3nicos, la elecci\u00f3n del microcontrolador adecuado es un paso cr\u00edtico. Cada microcontrolador se diferencia en varios aspectos t\u00e9cnicos y pr\u00e1cticos que determinan su rendimiento, facilidad de uso y costo. A continuaci\u00f3n, se explican los criterios utilizados en la tabla comparativa:</p> <ul> <li> <p>Perif\u00e9ricos: Son los m\u00f3dulos de hardware integrados que permiten la interacci\u00f3n del microcontrolador con el entorno. Incluyen interfaces de comunicaci\u00f3n (UART, SPI, I\u00b2C, USB, CAN), convertidores anal\u00f3gico-digital (ADC), generadores de PWM, temporizadores y otros. Su disponibilidad define qu\u00e9 tan vers\u00e1til puede ser el dispositivo en una aplicaci\u00f3n espec\u00edfica.</p> </li> <li> <p>Memoria: Se refiere a la capacidad de almacenamiento integrada.  </p> </li> <li>Flash: Guarda el programa principal (firmware).  </li> <li>SRAM: Es la memoria de trabajo usada durante la ejecuci\u00f3n.  </li> <li> <p>EEPROM o Flash externa: Permite guardar datos de manera permanente, incluso sin energ\u00eda.  </p> </li> <li> <p>Ecosistema: Hace referencia al conjunto de herramientas de software y librer\u00edas disponibles para programar y depurar el microcontrolador. Un ecosistema robusto (IDE, SDK, soporte en la comunidad) facilita el desarrollo, reduce la curva de aprendizaje y mejora la productividad.</p> </li> <li> <p>Costos: Indican el precio aproximado por unidad en vol\u00famenes peque\u00f1os. El costo influye directamente en la viabilidad de un proyecto, sobre todo en aplicaciones de bajo presupuesto o producci\u00f3n masiva.</p> </li> <li> <p>Arquitectura: Describe el tipo de n\u00facleo del procesador, ya sea de 8, 16 o 32 bits, y la familia a la que pertenece (por ejemplo, AVR, Cortex-M, Xtensa). La arquitectura determina las capacidades de procesamiento, eficiencia energ\u00e9tica y compatibilidad con herramientas de desarrollo.</p> </li> <li> <p>Velocidad de trabajo: Corresponde a la frecuencia de reloj m\u00e1xima (MHz) a la que puede operar el microcontrolador. A mayor velocidad, m\u00e1s operaciones por segundo, aunque tambi\u00e9n puede aumentar el consumo de energ\u00eda.</p> </li> </ul> <p>Esta comparativa permite visualizar de manera clara las diferencias entre distintas marcas y familias de microcontroladores, ayudando a seleccionar el dispositivo m\u00e1s apropiado seg\u00fan las necesidades del proyecto.</p>"},{"location":"controladores/#tabla-comparativa","title":"tabla comparativa","text":""},{"location":"controladores/#comparativa-de-microcontroladores_1","title":"Comparativa de Microcontroladores","text":"MCU Perif. Memoria Ecosistema $USD Arq. Vel. ATmega328P ADC10, UART, I\u00b2C, SPI, Timers, PWM 32KB / 2KB / 1KB EEPROM Arduino, MPLAB ~2.7 AVR 8-bit 20 MHz STM32F103C8 ADC12, USART, I\u00b2C, SPI, USB, CAN 64KB / 20KB STM32CubeIDE ~6 Cortex-M3 72 MHz LPC1768 Eth, USB OTG, CAN, UART, I\u00b2C, SPI, I\u00b2S, ADC, DAC 512KB / 64KB MCUXpresso ~14 Cortex-M3 100 MHz MSP430G2553 ADC10, UART, SPI, I\u00b2C, Timers 16KB / 512B CCS ~3.5 MSP430 16-bit 16 MHz ESP32-WROOM Wi-Fi, BT, ADC12, DAC, UART, SPI, I\u00b2C, PWM 520KB SRAM / 4MB flash ESP-IDF, Arduino ~3\u20137 Xtensa LX6 240 MHz RP2040 USB, UART, SPI, I\u00b2C, PWM, ADC, PIO 264KB SRAM / 2MB flash C/C++ SDK, MicroPython ~4 Cortex-M0+ 133 MHz"},{"location":"controladores/#resumen","title":"Resumen","text":"<p>La revisi\u00f3n comparativa de diferentes microcontroladores muestra que no existe un \u201cmejor\u201d dispositivo de manera absoluta, sino que cada uno responde a necesidades espec\u00edficas de dise\u00f1o.  </p> <ul> <li>Los ATmega328P y MSP430 destacan por su simplicidad, bajo consumo y facilidad de aprendizaje, ideales para proyectos educativos o aplicaciones sencillas.  </li> <li>Los STM32F103 y LPC1768 ofrecen mayor potencia de procesamiento y una amplia variedad de perif\u00e9ricos, adecuados para aplicaciones industriales o que requieren comunicaciones avanzadas.  </li> <li>El ESP32 resalta por integrar conectividad inal\u00e1mbrica (Wi-Fi y Bluetooth) a bajo costo, siendo muy utilizado en proyectos de IoT.  </li> <li>El RP2040 de Raspberry Pi se ha consolidado como una alternativa flexible y econ\u00f3mica, con un ecosistema creciente que lo hace atractivo para prototipado y desarrollo educativo.  </li> </ul> <p>En conclusi\u00f3n, la selecci\u00f3n del microcontrolador debe basarse en un balance entre costo, recursos disponibles, complejidad del proyecto y facilidad de desarrollo. Conocer las diferencias en perif\u00e9ricos, memoria, ecosistema, arquitectura y velocidad de trabajo permite tomar decisiones informadas que optimicen tanto el desempe\u00f1o como la viabilidad econ\u00f3mica de un proyecto embebido.</p>"},{"location":"controladores/#referencias","title":"Referencias","text":"<ul> <li>Microchip Technology Inc. (2025). ATmega328P Datasheet. Disponible en: https://www.microchip.com/en-us/product/ATmega328P </li> <li>STMicroelectronics (2025). STM32F103x8 Datasheet. Disponible en: https://www.st.com/en/microcontrollers-microprocessors/stm32f103.html </li> <li>NXP Semiconductors (2025). LPC1768 Product Data Sheet. Disponible en: https://www.nxp.com/part/LPC1768FBD100 </li> <li>Texas Instruments (2025). MSP430G2553 Datasheet. Disponible en: https://www.ti.com/product/MSP430G2553 </li> <li>Espressif Systems (2025). ESP32-WROOM-32 Datasheet. Disponible en: https://www.espressif.com/en/products/modules/esp32 </li> <li>Raspberry Pi Ltd. (2025). RP2040 Datasheet. Disponible en: https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html </li> </ul>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"laberinto/","title":"Robot Resolvedor de Laberintos (Raspberry Pi Pico 2)","text":"<p>Robot m\u00f3vil diferencial que avanza dentro de un laberinto usando motores DC con encoders y un sensor de distancia ToF frontal (VL53L0X). En esta primera versi\u00f3n, el robot avanza mientras no detecta muro de frente; cuando est\u00e1 demasiado cerca, realiza un giro de 90\u00b0 a la izquierda.</p>"},{"location":"laberinto/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Robot Resolvedor de Laberintos </li> <li>Autor: Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 08/12/2025 </li> <li>Descripci\u00f3n breve: Robot diferencial con dos motores y encoders, controlado por un TB6612FNG, que utiliza un sensor VL53L0X frontal para avanzar por el laberinto y girar al detectar un muro.</li> </ul> <p>Informaci\u00f3n del proyecto</p> <ul> <li>Lenguaje: C (Pico SDK)  </li> <li>MCU: Raspberry Pi Pico 2 (RP2040)  </li> <li>Librer\u00edas principales: </li> <li><code>pico/stdlib.h</code> </li> <li><code>hardware/gpio.h</code> </li> <li><code>hardware/pwm.h</code> </li> <li><code>hardware/i2c.h</code> </li> <li><code>tof.h</code> (driver del VL53L0X)  </li> <li>Sensores: </li> <li>1x VL53L0X (ToF) frontal, en bus I2C0  </li> <li>Encoders cuadratura en cada motor  </li> <li>Actuadores: </li> <li>2 motores DC (Pololu) con encoders  </li> <li>Puente H TB6612FNG  </li> <li>Tipo de control: </li> <li>Robot diferencial (dos ruedas motrices + rueda loca)  </li> <li>Control de velocidad con PWM  </li> <li>Correcci\u00f3n de trayectoria con encoders (funciones de prueba PD y P)</li> </ul>"},{"location":"laberinto/#material-utilizado","title":"Material utilizado","text":"<ul> <li>1x Raspberry Pi Pico 2  </li> <li>1x Puente H TB6612FNG  </li> <li>2x Motores DC con encoder (Pololu u otros equivalentes)  </li> <li>1x Sensor de distancia VL53L0X (ToF)  </li> <li>1x Rueda loca  </li> <li>Bater\u00eda (p. ej. 2S LiPo o 4x AA)  </li> <li>Cables, conectores y protoboard / PCB  </li> <li>PC con VS Code + CMake + Pico SDK  </li> </ul>"},{"location":"laberinto/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Implementar un robot diferencial utilizando un TB6612FNG y dos motores DC con encoders.  </li> <li>Leer encoders mediante interrupciones para medir el avance de cada rueda.  </li> <li>Leer un sensor VL53L0X por I2C para medir distancia frontal.  </li> <li>Implementar movimientos de alto nivel:</li> <li>Avanzar una cantidad de ticks fija.</li> <li>Girar aproximadamente 90\u00b0 a trav\u00e9s de los encoders.</li> <li>Implementar una l\u00f3gica b\u00e1sica de navegaci\u00f3n:</li> <li>Avanzar mientras no haya muro cerca.</li> <li>Girar a la izquierda cuando el muro frontal est\u00e1 demasiado cerca.  </li> </ul> <p>Esta versi\u00f3n sirve como base para integrar posteriormente un algoritmo completo de resoluci\u00f3n de laberintos (DFS, Flood Fill, etc.).</p>"},{"location":"laberinto/#3-circuito","title":"3) Circuito","text":"<p>El robot usa una PCB personalizada donde se conectan la Raspberry Pi Pico 2, el puente H TB6612FNG, los encoders de los motores, tres m\u00f3dulos de sensores IR y la etapa de alimentaci\u00f3n desde una bater\u00eda de 9 V.</p> <p>circuito </p>"},{"location":"laberinto/#31-sensores-ir-izquierda-frente-y-derecha","title":"3.1. Sensores IR (izquierda, frente y derecha)","text":"<p>En la parte superior de la PCB hay tres conectores:</p> <ul> <li>IR izq (<code>TSW-106-07-S-S</code>)</li> <li>IR adel (frontal)</li> <li>IR derc (derecha)</li> </ul> <p>Cada conector lleva:</p> <ul> <li>3V out (alimentaci\u00f3n del m\u00f3dulo IR)</li> <li>GND</li> <li>1 o 2 l\u00edneas de se\u00f1al hacia la Pico (seg\u00fan el m\u00f3dulo), etiquetadas como:</li> <li><code>gp3</code>, <code>gp4</code>, <code>gp5</code>, <code>gp14</code>, <code>gp15</code> (reservados para los IR)</li> </ul> <p>La idea es:</p> <ul> <li>Poder leer pared izquierda / derecha / frontal con sensores IR.</li> <li>Tener ya cableado el hardware, aunque en el c\u00f3digo de esta primera versi\u00f3n solo se use el sensor frontal ToF.</li> </ul> <p>Esquem\u00e1tico sensores IR + Pico: <code>![Sensores IR y Pico](../recursos/imgs/esquematico_ir_pico.png)</code></p>"},{"location":"laberinto/#32-motores-encoders-y-puente-h-tb6612fng","title":"3.2. Motores, encoders y puente H TB6612FNG","text":"<p>En el lado derecho de la PCB est\u00e1n los dos conectores de motor:</p> <ul> <li>Motor izquierdo (<code>TSW-106-07-S-S</code>)</li> <li><code>M1 / M2</code>: terminales del motor</li> <li><code>C1 / C2</code>: canales del encoder (izquierda)</li> <li> <p><code>VCC</code> y <code>GND</code></p> </li> <li> <p>Motor derecho</p> </li> <li><code>M1 / M2</code>: terminales del motor</li> <li><code>C1 / C2</code>: canales del encoder (derecha)</li> <li><code>VCC</code> y <code>GND</code></li> </ul> <p>El puente H es un m\u00f3dulo ROB-14450 (TB6612FNG). El mapeo contra la Pico 2 (seg\u00fan tu esquem\u00e1tico y c\u00f3digo) queda:</p> <ul> <li>PWM de velocidad</li> <li><code>PWMA</code> \u2192 <code>gp6</code> \u2192 motor izquierdo  </li> <li> <p><code>PWMB</code> \u2192 <code>gp7</code> \u2192 motor derecho  </p> </li> <li> <p>Direcci\u00f3n de motores</p> </li> <li>Motor izquierdo:  <ul> <li><code>AIN1</code> \u2192 <code>gp9</code> </li> <li><code>AIN2</code> \u2192 <code>gp10</code></li> </ul> </li> <li> <p>Motor derecho:  </p> <ul> <li><code>BIN1</code> \u2192 <code>gp11</code> </li> <li><code>BIN2</code> \u2192 <code>gp12</code></li> </ul> </li> <li> <p>Standby</p> </li> <li> <p><code>STBY</code> se lleva a un GPIO (gp8 + resistor) y se mantiene en alto, habilitando el driver.</p> </li> <li> <p>Encoders</p> </li> <li>Izquierda:<ul> <li><code>ENC_LA_PIN</code> \u2192 <code>gp18</code> (C1 izq)  </li> <li><code>ENC_LB_PIN</code> \u2192 <code>gp19</code> (C2 izq)</li> </ul> </li> <li>Derecha:<ul> <li><code>ENC_RA_PIN</code> \u2192 <code>gp16</code> (C1 der)  </li> <li><code>ENC_RB_PIN</code> \u2192 <code>gp17</code> (C2 der)</li> </ul> </li> </ul> <p>Esquem\u00e1tico motores + TB6612FNG: <code>![Motores y puente H](../recursos/imgs/esquematico_motores_tb6612.png)</code></p>"},{"location":"laberinto/#33-alimentacion","title":"3.3. Alimentaci\u00f3n","text":"<p>La PCB est\u00e1 pensada para alimentarse con una bater\u00eda de 9 V:</p> <ol> <li>Conector \u201calimentaci\u00f3n\u201d: entra la bater\u00eda (9 V y GND).</li> <li>Un switch en serie permite encender/apagar el robot.</li> <li>Despu\u00e9s del switch hay un capacitor de filtrado y una resistencia serie peque\u00f1a.</li> <li>Un regulador LM1117-IMP-5.0 baja la tensi\u00f3n de ~9 V a la tensi\u00f3n de l\u00f3gica (<code>3v out</code> en el esquem\u00e1tico), que alimenta:</li> <li>La Raspberry Pi Pico 2 (a trav\u00e9s de su pin de entrada de tensi\u00f3n).</li> <li>El puente H TB6612FNG (<code>VCC</code>).</li> <li>Los sensores IR y el resto de la l\u00f3gica.</li> </ol> <p>Adem\u00e1s hay un LED de encendido con su resistencia en serie para indicar que la placa est\u00e1 alimentada.</p> <p>Esquem\u00e1tico de alimentaci\u00f3n: <code>![Alimentaci\u00f3n y regulador](../recursos/imgs/esquematico_alimentacion.png)</code></p>"},{"location":"laberinto/#34-pcb-final","title":"3.4. PCB final","text":"<p>La PCB tiene forma casi octagonal para adaptarse al contorno del robot. En la vista de ruteo se distinguen:</p> <ul> <li>Conector de la Pico 2 en el centro-izquierda.</li> <li>Conectores de IR izq / IR adel / IR derc en el borde superior.</li> <li>Conectores de Motor izquierdo y Motor derecho a los lados.</li> <li>Zona de alimentaci\u00f3n en la parte inferior (conector de bater\u00eda + switch + regulador).</li> <li>Plano de GND y pistas de potencia un poco m\u00e1s gruesas para los motores.</li> </ul> <p>PCB enrutada del robot: <code>![PCB robot laberinto](../recursos/imgs/pcb_robot_laberinto.png)</code></p>"},{"location":"laberinto/#4-codigo","title":"4) C\u00f3digo","text":""},{"location":"laberinto/#41-codigo-completo","title":"4.1 C\u00f3digo completo","text":"<p>```c</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include &lt;stdbool.h&gt;\n\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/i2c.h\"\n#include \"pico/binary_info.h\"\n#include \"tof.h\"\n\n\n//---------variables de control PID---------\n#define KP_PD   0.015f   // Ganancia proporcional (aj\u00fastala)\n#define KD_PD   0.01f    // Ganancia derivativa (aj\u00fastala)\n#define I2C_PORT i2c0\n\n#define XSHUT1 13 //adelante\n\n// ---------------- Pines TB6612FNG ----------------\n// Motor IZQUIERDO -&gt; Canal A\n#define AIN1_PIN   10    // AIN1\n#define AIN2_PIN   11    // AIN2\n#define PWMA_PIN   7     // PWMA (PWM)\n\n// Motor DERECHO -&gt; Canal B\n#define BIN1_PIN   8     // BIN1\n#define BIN2_PIN   9     // BIN2\n#define PWMB_PIN   6     // PWMB\n\n#define STBY_PIN   12    // STBY (standby, debe estar en 1)\n\n// ---------------- Encoders ----------------\n// Llanta IZQUIERDA\n#define ENC_LA_PIN   18   // C1 izquierda\n#define ENC_LB_PIN   19   // C2 izquierda\n\n// Llanta DERECHA\n#define ENC_RA_PIN   16   // C1 derecha\n#define ENC_RB_PIN   17   // C2 derecha\n\n// ---------------- Par\u00e1metros del robot (AJUSTAR) ----------------\n#define TICKS_GIRO_90   300   // VALOR DE EJEMPLO, C\u00c1MBIALO DESPU\u00c9S\n\n// ---------------- Variables globales encoder ----------------\nvolatile int32_t encoder_left_count  = 0;\nvolatile int32_t encoder_right_count = 0;\n\n// PWM\nstatic uint slice_left;\nstatic uint slice_right;\nstatic const uint16_t PWM_WRAP = 1000;  // resoluci\u00f3n de PWM (0\u20131000)\n\n// Peque\u00f1a funci\u00f3n abs para int32\nstatic inline int32_t i32_abs(int32_t x) {\n    return (x &gt;= 0) ? x : -x;\n}\n\nvoid motor_set_right(int16_t speed) {\n    if (speed &gt; 100)  speed = -100;\n    if (speed &lt; -100) speed = 100;\n\n    // Aqu\u00ed invertimos el sentido respecto al izquierdo\n    if (speed &gt; 0) {\n        // Adelante (pero el motor est\u00e1 f\u00edsicamente invertido)\n        gpio_put(BIN1_PIN, 0);\n        gpio_put(BIN2_PIN, 1);\n    } else if (speed &lt; 0) {\n        // Atr\u00e1s\n        gpio_put(BIN1_PIN, 1);\n        gpio_put(BIN2_PIN, 0);\n    } else {\n        gpio_put(BIN1_PIN, 0);\n        gpio_put(BIN2_PIN, 0);\n    }\n\n    uint16_t mag = (speed &gt;= 0) ? (uint16_t)speed : (uint16_t)(-speed);\n    uint16_t duty = (uint16_t)((mag * PWM_WRAP) / 100);\n    pwm_set_gpio_level(PWMB_PIN, duty);\n}\n\n// Motor IZQUIERDO\nvoid motor_set_left(int16_t speed) {\n    if (speed &gt; 100)  speed = -100;\n    if (speed &lt; -100) speed = 100;\n\n    if (speed &gt; 0) {\n        gpio_put(AIN1_PIN, 1);\n        gpio_put(AIN2_PIN, 0);\n    } else if (speed &lt; 0) {\n        gpio_put(AIN1_PIN, 0);\n        gpio_put(AIN2_PIN, 1);\n    } else {\n        gpio_put(AIN1_PIN, 0);\n        gpio_put(AIN2_PIN, 0);\n    }\n\n    uint16_t mag = (speed &gt;= 0) ? (uint16_t)speed : (uint16_t)(-speed);\n    uint16_t duty = (uint16_t)((mag * PWM_WRAP) / 100);\n    pwm_set_gpio_level(PWMA_PIN, duty);\n}\n\n// Parar ambos motores\nvoid robot_parar(void) {\n    motor_set_left(0);\n    motor_set_right(0);\n}\n\n// Control PD para que el robot vaya recto usando los encoders\nvoid robot_prueba_recto_PD(int16_t base_speed, uint32_t duracion_ms, uint32_t paso_ms) {\n    encoder_left_count  = 0;\n    encoder_right_count = 0;\n\n    float e_prev = 0.0f;  // error anterior\n\n    uint32_t t = 0;\n    while (t &lt; duracion_ms) {\n        // Leemos los encoders\n        int32_t L = encoder_left_count;\n        int32_t R = encoder_right_count;\n\n        // Usamos magnitud (valor absoluto) para evitar problemas de signo\n        int32_t Lmag = (L &gt;= 0) ? L : -L;\n        int32_t Rmag = (R &gt;= 0) ? R : -R;\n\n        // Error: diferencia de distancias recorridas\n        float e  = (float)(Lmag - Rmag);\n        float de = e - e_prev;   // derivada discreta\n\n        // Ley de control PD\n        float u = KP_PD * e + KD_PD * de;\n\n        // Limitamos la correcci\u00f3n para que NO domine a base_speed\n        float max_u = base_speed * 0.3f;   // 30% de la velocidad base\n        if (u &gt;  max_u) u =  max_u;\n        if (u &lt; -max_u) u = -max_u;\n\n        // Calculamos velocidades\n        float sL = (float)base_speed - u;\n        float sR = (float)base_speed + u;\n\n        // Saturamos a [0, 100] para NO permitir reversa en esta prueba\n        if (sL &gt; 100.0f)  sL = 100.0f;\n        if (sL &lt; 0.0f)    sL = 0.0f;\n        if (sR &gt; 100.0f)  sR = 100.0f;\n        if (sR &lt; 0.0f)    sR = 0.0f;\n\n        int16_t speed_left  = (int16_t)sL;\n        int16_t speed_right = (int16_t)sR;\n\n        motor_set_left(speed_left);\n        motor_set_right(speed_right);\n\n        printf(\"t=%lu ms | L=%ld | R=%ld | e=%.1f | u=%.2f | sL=%d | sR=%d\\n\",\n            t, L, R, e, u, speed_left, speed_right);\n\n        e_prev = e;\n        sleep_ms(paso_ms);\n        t += paso_ms;\n    }\n\n    robot_parar();\n}\n\n// ---------------- ISR del encoder para DOS llantas ----------------\nvoid encoder_isr(uint gpio, uint32_t events) {\n    // Leemos siempre todos los canales\n    bool aL = gpio_get(ENC_LA_PIN);\n    bool bL = gpio_get(ENC_LB_PIN);\n    bool aR = gpio_get(ENC_RA_PIN);\n    bool bR = gpio_get(ENC_RB_PIN);\n\n    // ---- LLANTA IZQUIERDA ----\n    if (gpio == ENC_LA_PIN) {\n        if (aL == bL) {\n            encoder_left_count++;\n        } else {\n            encoder_left_count--;\n        }\n    } else if (gpio == ENC_LB_PIN) {\n        if (aL != bL) {\n            encoder_left_count++;\n        } else {\n            encoder_left_count--;\n        }\n    }\n\n    // ---- LLANTA DERECHA ----\n    else if (gpio == ENC_RA_PIN) {\n        if (aR == bR) {\n            encoder_right_count++;\n        } else {\n            encoder_right_count--;\n        }\n    } else if (gpio == ENC_RB_PIN) {\n        if (aR != bR) {\n            encoder_right_count++;\n        } else {\n            encoder_right_count--;\n        }\n    }\n}\n\n// ---------------- Funciones de alto nivel: robot ----------------\n\n// Avanzar usando ticks de la llanta izquierda\nvoid robot_adelante(int16_t base_speed, int32_t ticks_objetivo) {\n    encoder_left_count  = 0;\n    encoder_right_count = 0;\n\n    const float Kp = 0.1f;     // empieza peque\u00f1o\n    const int16_t MAX_CORR = 30;   // cu\u00e1nto m\u00e1x. puede corregir\n    const int16_t MIN_CMD  = 30;   // m\u00ednimo para que el motor venza fricci\u00f3n\n    const int16_t MAX_CMD  = 255;  // o lo que uses\n\n    motor_set_left(base_speed);\n    motor_set_right(base_speed);\n\n    while (1) {\n        int32_t ticks_L = encoder_left_count;\n        int32_t ticks_R = encoder_right_count;\n\n        int32_t prom = (i32_abs(ticks_L) + i32_abs(ticks_R)) / 2;\n        if (prom &gt;= ticks_objetivo) {\n            break;\n        }\n\n        // error = diferencia de avance entre ruedas\n        int32_t error = ticks_L - ticks_R;\n\n        // --- solo P, sin D ---\n        float corr_f = Kp * (float)error;\n        int16_t corr = (int16_t)corr_f;\n\n        // limitar correcci\u00f3n\n        if (corr &gt;  MAX_CORR) corr =  MAX_CORR;\n        if (corr &lt; -MAX_CORR) corr = -MAX_CORR;\n\n        int16_t left_cmd  = base_speed - corr;\n        int16_t right_cmd = base_speed + corr;\n\n        // NO permitir cambiar de sentido: comandos siempre positivos\n        if (left_cmd  &lt; MIN_CMD) left_cmd  = MIN_CMD;\n        if (right_cmd &lt; MIN_CMD) right_cmd = MIN_CMD;\n        if (left_cmd  &gt; MAX_CMD) left_cmd  = MAX_CMD;\n        if (right_cmd &gt; MAX_CMD) right_cmd = MAX_CMD;\n\n        motor_set_left(left_cmd);\n        motor_set_right(right_cmd);\n\n        sleep_ms(5);\n    }\n\n    robot_parar();\n}\n\nvoid robot_adelante_basic(int16_t speed, int32_t ticks_objetivo) {\n    encoder_left_count  = 0;\n    encoder_right_count = 0;\n\n    motor_set_left(speed);\n    motor_set_right(speed);\n\n    while (i32_abs(encoder_left_count) &lt; ticks_objetivo) {\n        tight_loop_contents();\n    }\n\n    robot_parar();\n}\n\nvoid turnL(int16_t base_speed, int32_t ticks_objetivo) {\n    encoder_left_count  = 0;\n    encoder_right_count = 0;\n\n    const float Kp = 0.1f;     // empieza peque\u00f1o\n    const int16_t MAX_CORR = 30;   // cu\u00e1nto m\u00e1x. puede corregir\n    const int16_t MIN_CMD  = 30;   // m\u00ednimo para que el motor venza fricci\u00f3n\n    const int16_t MAX_CMD  = 255;  // o lo que uses\n\n    motor_set_left(-base_speed);\n    motor_set_right(base_speed);\n\n    while (1) {\n        int32_t ticks_L = encoder_left_count;\n        int32_t ticks_R = encoder_right_count;\n\n        int32_t prom = (i32_abs(ticks_L) + i32_abs(ticks_R)) / 2;\n        if (prom &gt;= ticks_objetivo) {\n            break;\n        }\n\n        // error = diferencia de avance entre ruedas\n        int32_t error = ticks_L - ticks_R;\n\n        // --- solo P, sin D ---\n        float corr_f = Kp * (float)error;\n        int16_t corr = (int16_t)corr_f;\n\n        // limitar correcci\u00f3n\n        if (corr &gt;  MAX_CORR) corr =  MAX_CORR;\n        if (corr &lt; -MAX_CORR) corr = -MAX_CORR;\n\n        int16_t left_cmd  = base_speed - corr;\n        int16_t right_cmd = base_speed + corr;\n\n        // NO permitir cambiar de sentido: comandos siempre positivos\n        if (left_cmd  &lt; MIN_CMD) left_cmd  = MIN_CMD;\n        if (right_cmd &lt; MIN_CMD) right_cmd = MIN_CMD;\n        if (left_cmd  &gt; MAX_CMD) left_cmd  = MAX_CMD;\n        if (right_cmd &gt; MAX_CMD) right_cmd = MAX_CMD;\n\n        motor_set_left(left_cmd);\n        motor_set_right(right_cmd);\n\n        sleep_ms(5);\n    }\n\n    robot_parar();\n}\n\n// Giro de ~90\u00b0 a la DERECHA\nvoid robot_giro_90_derecha(int16_t speed) {\n    encoder_left_count  = 0;\n    encoder_right_count = 0;\n\n    motor_set_left(speed);\n    motor_set_right(-speed);\n\n    while (i32_abs(encoder_left_count) &lt; TICKS_GIRO_90) {\n        tight_loop_contents();\n    }\n\n    robot_parar();\n}\n\n// Giro de ~90\u00b0 a la IZQUIERDA\nvoid robot_giro_90_izquierda(int16_t speed) {\n    encoder_left_count  = 0;\n    encoder_right_count = 0;\n\n    motor_set_left(-speed);\n    motor_set_right(speed);\n\n    while (i32_abs(encoder_left_count) &lt; TICKS_GIRO_90) {\n        tight_loop_contents();\n    }\n\n    robot_parar();\n}\n\n// Prueba: ir recto cierto tiempo y ver pulsos de ambas ruedas\nvoid robot_prueba_recto(int16_t speed, uint32_t duracion_ms, uint32_t paso_ms) {\n    encoder_left_count  = 0;\n    encoder_right_count = 0;\n\n    motor_set_left(speed);\n    motor_set_right(speed);\n\n    uint32_t t = 0;\n    while (t &lt; duracion_ms) {\n        printf(\"t = %lu ms | L = %ld | R = %ld | diff = %ld\\n\",\n            t,\n            encoder_left_count,\n            encoder_right_count,\n            encoder_left_count - encoder_right_count);\n        sleep_ms(paso_ms);\n        t += paso_ms;\n    }\n\n    robot_parar();\n}\n\n// ---------------- main ----------------\nint main() {\n    stdio_init_all();\n    sleep_ms(4000);\n\n    // Inicializar I2C para el VL53L0X\n    i2c_init(I2C_PORT, 400 * 1000);\n    gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C);\n    gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C);\n    gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN);\n    gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN);\n    bi_decl(bi_2pins_with_func(PICO_DEFAULT_I2C_SDA_PIN,\n                            PICO_DEFAULT_I2C_SCL_PIN,\n                            GPIO_FUNC_I2C));\n\n    // XSHUT del VL53L0X\n    gpio_init(XSHUT1);\n    gpio_set_dir(XSHUT1, GPIO_OUT);\n    gpio_put(XSHUT1, 0);\n    sleep_ms(50);\n\n    int ok;\n    gpio_put(XSHUT1, 1);\n    sleep_ms(10);\n    ok = tofInit(0, 0x29, 1000);\n    if (ok != 1) {\n        printf(\"ERROR iniciando sensor 1 (ret=%d)\\n\", ok);\n        while (1) tight_loop_contents();\n    }\n\n    sleep_ms(500);\n\n    //=========================\n    // Configuraci\u00f3n de motores\n    //=========================\n\n    // Motor izquierdo\n    gpio_init(AIN1_PIN);\n    gpio_set_dir(AIN1_PIN, GPIO_OUT);\n    gpio_put(AIN1_PIN, 0);\n\n    gpio_init(AIN2_PIN);\n    gpio_set_dir(AIN2_PIN, GPIO_OUT);\n    gpio_put(AIN2_PIN, 0);\n\n    // Motor derecho\n    gpio_init(BIN1_PIN);\n    gpio_set_dir(BIN1_PIN, GPIO_OUT);\n    gpio_put(BIN1_PIN, 0);\n\n    gpio_init(BIN2_PIN);\n    gpio_set_dir(BIN2_PIN, GPIO_OUT);\n    gpio_put(BIN2_PIN, 0);\n\n    // STBY en alto para salir de standby\n    gpio_init(STBY_PIN);\n    gpio_set_dir(STBY_PIN, GPIO_OUT);\n    gpio_put(STBY_PIN, 1);\n\n    // -------- Configuraci\u00f3n PWM --------\n    // Izquierdo\n    gpio_set_function(PWMA_PIN, GPIO_FUNC_PWM);\n    slice_left = pwm_gpio_to_slice_num(PWMA_PIN);\n    pwm_set_wrap(slice_left, PWM_WRAP);\n    pwm_set_clkdiv(slice_left, 100.0f);   // ~1.25 kHz\n    pwm_set_gpio_level(PWMA_PIN, 0);\n    pwm_set_enabled(slice_left, true);\n\n    // Derecho\n    gpio_set_function(PWMB_PIN, GPIO_FUNC_PWM);\n    slice_right = pwm_gpio_to_slice_num(PWMB_PIN);\n    pwm_set_wrap(slice_right, PWM_WRAP);\n    pwm_set_clkdiv(slice_right, 100.0f);\n    pwm_set_gpio_level(PWMB_PIN, 0);\n    pwm_set_enabled(slice_right, true);\n\n    // -------- Configuraci\u00f3n encoders --------\n    // Izquierdo\n    gpio_init(ENC_LA_PIN);\n    gpio_set_dir(ENC_LA_PIN, GPIO_IN);\n    gpio_pull_up(ENC_LA_PIN);\n\n    gpio_init(ENC_LB_PIN);\n    gpio_set_dir(ENC_LB_PIN, GPIO_IN);\n    gpio_pull_up(ENC_LB_PIN);\n\n    // Derecho\n    gpio_init(ENC_RA_PIN);\n    gpio_set_dir(ENC_RA_PIN, GPIO_IN);\n    gpio_pull_up(ENC_RA_PIN);\n\n    gpio_init(ENC_RB_PIN);\n    gpio_set_dir(ENC_RB_PIN, GPIO_IN);\n    gpio_pull_up(ENC_RB_PIN);\n\n    // Un solo callback para todos los pines de encoder\n    gpio_set_irq_enabled_with_callback(\n        ENC_LA_PIN,\n        GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL,\n        true,\n        &amp;encoder_isr\n    );\n    gpio_set_irq_enabled(ENC_LB_PIN, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(ENC_RA_PIN, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);\n    gpio_set_irq_enabled(ENC_RB_PIN, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);\n\n    sleep_ms(1000);\n    printf(\"Inicio robot con TB6612 + encoders izquierda/derecha\\n\");\n\n    const int LIMITE_FRONT = 120;    // mm (distancia m\u00ednima al frente)\n    const int16_t VEL_BASE = -20;    // velocidad para avanzar (ajustada a cableado real)\n    const int32_t TICKS_PASO = 80;   // cu\u00e1ntos ticks avanza en cada \"paso\"\n\n    while (true) {\n        // ---------- 4.1 Leer sensor frontal ----------\n        vl53l0x_setAddress(0x29);   // frontal\n        int d_front = tofReadDistance();\n\n        printf(\"F=%4d mm\\n\", d_front);\n\n        // Si la lectura del frontal es inv\u00e1lida (&lt;0), tr\u00e1tala como \"muy lejos\"\n        if (d_front &lt; 0) d_front = 2000;\n\n        // ---------- 4.2 L\u00f3gica de movimiento ----------\n        if (d_front &gt; LIMITE_FRONT) {\n            // Hay espacio al frente -&gt; dar un pasito recto\n            robot_adelante_basic(VEL_BASE, TICKS_PASO);\n        } else {\n            // Demasiado cerca del muro frontal\n            robot_parar();\n            robot_giro_90_izquierda(VEL_BASE);\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"laberinto/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"laberinto/#51-mapeo-de-pines-y-modulos","title":"5.1. Mapeo de pines y m\u00f3dulos","text":"<p>Motores (TB6612FNG):</p> <p>Dos funciones principales:</p> <ul> <li><code>motor_set_left(int16_t speed)</code></li> <li><code>motor_set_right(int16_t speed)</code></li> </ul> <p>Reciben una velocidad en el rango aproximado <code>[-100, 100]</code> y:</p> <ul> <li>Ajustan la direcci\u00f3n (pines <code>AINx</code> / <code>BINx</code>).</li> <li>Ajustan el duty cycle del PWM (pines <code>PWMA</code> / <code>PWMB</code>).</li> </ul> <p>Encoders:</p> <ul> <li>Cada rueda tiene dos canales (A y B).</li> <li>La rutina <code>encoder_isr()</code> se registra como callback para los flancos de todos los pines de encoder.</li> <li>En funci\u00f3n del estado relativo de A y B se incrementa o decrementa:</li> <li><code>encoder_left_count</code></li> <li><code>encoder_right_count</code></li> </ul> <p>Sensor VL53L0X:</p> <ul> <li>Se inicializa por I2C en la direcci\u00f3n <code>0x29</code> usando <code>tofInit()</code>.</li> <li>En el bucle principal se usa <code>tofReadDistance()</code> para obtener la distancia frontal en mm.</li> </ul>"},{"location":"laberinto/#52-funciones-de-movimiento","title":"5.2. Funciones de movimiento","text":"<ul> <li> <p><code>robot_adelante_basic(int16_t speed, int32_t ticks_objetivo)</code>   Avanza con una velocidad fija hasta que el encoder izquierdo alcanza <code>ticks_objetivo</code>.</p> </li> <li> <p><code>robot_adelante(...)</code>   Similar, pero con una correcci\u00f3n proporcional basada en la diferencia de ticks entre ruedas para mantener el rumbo.</p> </li> <li> <p><code>robot_prueba_recto_PD(...)</code>   Implementa un control PD sobre la diferencia de encoders para que el robot avance lo m\u00e1s recto posible, ajustando din\u00e1micamente <code>sL</code> y <code>sR</code>.</p> </li> <li> <p><code>robot_giro_90_izquierda(int16_t speed)</code> y <code>robot_giro_90_derecha(int16_t speed)</code>   Giran el robot sobre su centro (una rueda hacia adelante y la otra hacia atr\u00e1s) hasta alcanzar <code>TICKS_GIRO_90</code> en el encoder, lo que se calibra para aproximar un giro de 90\u00b0.</p> </li> </ul>"},{"location":"laberinto/#53-bucle-principal-logica-de-navegacion","title":"5.3. Bucle principal: l\u00f3gica de navegaci\u00f3n","text":"<p>En <code>main()</code> se ejecuta un bucle infinito:</p> <ol> <li>Lectura del sensor frontal:</li> <li>Se obtiene <code>d_front = tofReadDistance();</code>.</li> <li> <p>Si <code>d_front &lt; 0</code>, se asume que est\u00e1 muy lejos o hubo error de lectura y se reemplaza por <code>2000</code> mm.</p> </li> <li> <p>Decisi\u00f3n de movimiento:</p> </li> <li>Si <code>d_front &gt; LIMITE_FRONT</code> (por ejemplo, 120 mm):  <ul> <li>No hay muro cercano \u2192 se llama a <code>robot_adelante_basic(VEL_BASE, TICKS_PASO);</code>, es decir, se avanza una cantidad de ticks fija.</li> </ul> </li> <li>Si <code>d_front &lt;= LIMITE_FRONT</code>:  <ul> <li>Hay un muro muy cerca \u2192 se detiene el robot (<code>robot_parar()</code>) y se realiza un giro de 90\u00b0 a la izquierda (<code>robot_giro_90_izquierda(VEL_BASE);</code>).</li> </ul> </li> </ol> <p>Esta l\u00f3gica implementa una navegaci\u00f3n reactiva simple que evita chocar con el muro frontal y genera un comportamiento tipo \u201cseguir girando a la izquierda\u201d cuando encuentra obst\u00e1culos.</p>"},{"location":"laberinto/#6-consideraciones-de-hardware","title":"6) Consideraciones de hardware","text":"<p>Calibraci\u00f3n de <code>TICKS_GIRO_90</code>: El valor <code>#define TICKS_GIRO_90 300</code> es aproximado. Debe calibrarse emp\u00edricamente haciendo girar el robot sobre s\u00ed mismo y ajustando hasta obtener un giro de ~90\u00b0.</p> <p>Velocidad y signo de <code>VEL_BASE</code>: En el c\u00f3digo se usa <code>VEL_BASE = -20</code>. Esto se debe a la forma en que est\u00e1n conectados los motores y a c\u00f3mo se definieron los sentidos en <code>motor_set_left()</code> y <code>motor_set_right()</code>. Si al probar el robot este avanza hacia atr\u00e1s, bastar\u00e1 con cambiar el signo o la convenci\u00f3n de pines.</p> <p>Alimentaci\u00f3n:</p> <ul> <li>Es recomendable usar alimentaci\u00f3n separada para motores y l\u00f3gica (por ejemplo, LiPo para motores y regulador a 5 V / 3.3 V para la Pico).</li> <li>Siempre unir las tierras (GND).</li> </ul> <p>Ruido de motores: Los motores pueden introducir ruido en la alimentaci\u00f3n y afectar el I2C o incluso causar resets. Es recomendable:</p> <ul> <li>Colocar capacitores de desacople cerca de la Pico y del TB6612.</li> <li>Mantener los cables de se\u00f1ales lo m\u00e1s cortos posible.</li> </ul> <p>Montaje del sensor VL53L0X: D</p>"},{"location":"rana/","title":"Proyecto rana","text":""},{"location":"rana/#rana","title":"RANA","text":"<p>La contaminaci\u00f3n de lagos, estanques y peque\u00f1os cuerpos de agua es un problema creciente que afecta tanto al medio ambiente como a las comunidades locales. La acumulaci\u00f3n de basura pl\u00e1stica, hojas y residuos org\u00e1nicos provoca da\u00f1os en la biodiversidad, genera malos olores y dificulta el acceso al agua para fines recreativos o agr\u00edcolas.  </p> <p>La limpieza manual de estos espacios resulta complicada y poco eficiente, por lo que surge la necesidad de soluciones accesibles, aut\u00f3nomas y adaptadas a estos entornos. Este proyecto propone el dise\u00f1o de un robot acu\u00e1tico de navegaci\u00f3n asistida, capaz de recolectar residuos flotantes de forma econ\u00f3mica, sustentable y escalable:contentReference[oaicite:0]{index=0}.  </p> <p>Descargar especificaci\u00f3n (PDF)</p> <p>RANA </p>"},{"location":"rana/#analisis-sobre-la-problematica","title":"Analis\u00eds sobre la problematica:","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"rana/#diagrama-de-gantt-de-las-actividades-que-se-realizaran","title":"Diagrama de Gantt de las actividades que se realizaran:","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"rana/#rana-robot-acuatico-de-navegacion-asistida","title":"RANA \u2014 Robot Acu\u00e1tico de Navegaci\u00f3n Asistida","text":"<p>Aplicaci\u00f3n de la diapositiva \u201cCreando Valor\u201d al proyecto RANA</p> Categor\u00eda Descripci\u00f3n Socios Clave - Compa\u00f1eros y profesores que nos ayuden a mejorar el dise\u00f1o.   - Laboratorios de la universidad donde podamos probar el robot.   - Proveedores de piezas b\u00e1sicas (motores, sensores, paneles solares peque\u00f1os).   - Comunidades que nos permitan probar el robot en estanques peque\u00f1os. Actividades Clave - Dise\u00f1ar y armar el prototipo.   - Probarlo en agua para evaluar limpieza.   - Instalar sensores b\u00e1sicos.   - Dar mantenimiento y ajustar dise\u00f1o.   - Difundir el proyecto en redes o carteles. Propuesta de Valor - Robot econ\u00f3mico y f\u00e1cil de usar.   - Funciona aut\u00f3nomo o con control remoto.   - Mide par\u00e1metros b\u00e1sicos del agua.   - Limpia peque\u00f1as \u00e1reas y genera conciencia ambiental. Relaci\u00f3n con Clientes - Ense\u00f1ar a usar el robot.   - Pedir retroalimentaci\u00f3n.   - Colaborar con grupos ambientales. Segmentos de Clientes - Universidades o laboratorios.   - Comunidades con estanques.   - Grupos estudiantiles ambientales. Recursos Clave - Arduino, sensores, motores, bater\u00edas.   - Taller o laboratorio.   - T\u00fa y tus compa\u00f1eros.   - Materiales reciclables o econ\u00f3micos. Canales - Presentaciones en la universidad.   - Redes sociales.   - Ferias estudiantiles de innovaci\u00f3n. Estructura de Costos - Compra de componentes b\u00e1sicos.   - Ensamblaje y pruebas.   - Materiales de difusi\u00f3n. Fuentes de Ingreso - Apoyo de la universidad o becas.   - Premios en concursos estudiantiles.   - Posible venta a laboratorios o grupos estudiantiles."},{"location":"rana/#1-la-oferta-que-quiere-la-gente","title":"1) La oferta: \u00bfqu\u00e9 quiere la gente?","text":""},{"location":"rana/#rango-de-productos-oferta","title":"Rango de productos (oferta)","text":"<ul> <li>RANA Go (MVP) \u2014 Robot de limpieza con navegaci\u00f3n asistida (teleoperado con ayudas de rumbo y anticolisi\u00f3n), skimmer para s\u00f3lidos flotantes, filtro fino y telemetr\u00eda b\u00e1sica (turbidez, temperatura).</li> <li> <p>RANA Pro \u2014 Semi-aut\u00f3nomo con rutas guiadas, geocercas, detecci\u00f3n de obst\u00e1culos (LiDAR/c\u00e1mara/US), mapas de calor de basura y reportes autom\u00e1ticos para cumplimiento (antes/despu\u00e9s, kg recogidos, horas de operaci\u00f3n).</p> </li> <li> <p>Servicios complementarios: estudio inicial (l\u00ednea base de contaminaci\u00f3n), mantenimiento preventivo, retiro y disposici\u00f3n certificada, suscripci\u00f3n de monitoreo ambiental (turbidez, pH, DO, clorofila, cianobacterias opcional).</p> </li> </ul>"},{"location":"rana/#segmentos-objetivo-targeted","title":"Segmentos objetivo (targeted)","text":"<ol> <li>Municipios y organismos de agua (lagos urbanos, canales).</li> <li>Administradores de parques y clubs n\u00e1uticos (imagen p\u00fablica, seguridad sanitaria).</li> <li>Hoteles y marinas privadas (experiencia del visitante).</li> <li>Universidades/labs ambientales (datos y campo).</li> </ol>"},{"location":"rana/#2-propuesta-de-valor-insightful-unique-targeted","title":"2) Propuesta de valor (INSIGHTFUL \u2022 UNIQUE \u2022 TARGETED)","text":"<p>Dolores reales: limpieza manual costosa e intermitente; quejas vecinales por mal olor/algas; falta de datos verificables para justificar presupuesto. Ganancias: limpieza m\u00e1s frecuente y segura, evidencia cuantificada para reportes y decisiones, operaci\u00f3n silenciosa y con bajo OPEX.</p> <p>\u00daNICA (Unique) - Navegaci\u00f3n asistida: combina control humano con ayudas inteligentes (mantener rumbo, evitar colisiones, \u201climpia-en-ruta\u201d optimizada). - Data-first: reportes con kg/hora, m\u00b2 cubiertos, turbidez y mapas de calor \u2192 justifica inversi\u00f3n y muestra impacto. - Modular: skimmer, microalga boom, micro-dragado ligero, sensor pack opcional.</p> <p>DIRIGIDA (Targeted) - \u201cPeque\u00f1os-medianos cuerpos de agua urbanos (1\u201350 ha) con basura flotante recurrente y presi\u00f3n social por imagen/olores\u201d, responsable: Direcci\u00f3n de Parques/Servicios P\u00fablicos.</p>"},{"location":"rana/#creando-valor-rana-robot-acuatico-de-navegacion-asistida","title":"Creando Valor \u2014 RANA (Robot Acu\u00e1tico de Navegaci\u00f3n Asistida)","text":"INSIGHTFUL (Necesidades reales) UNIQUE (Dif\u00edcil de replicar) TARGETED (Cliente apasionado) Limpieza frecuente y segura de lagos/canales urbanos. Navegaci\u00f3n asistida: rumbo estable, retorno seguro y anticolisi\u00f3n. Municipios/organismos de agua con presi\u00f3n por quejas vecinales. indicadores cuantificables para justificar presupuesto (kg de residuos, m\u00b2 cubiertos, turbidez reducida). Operaci\u00f3n data-first con reportes autom\u00e1ticos y mapas de calor de basura. Direcciones de Parques/Servicios P\u00fablicos responsables de imagen y sanidad. Respuesta r\u00e1pida post-lluvias y en temporadas altas de residuos. Arquitectura modular (skimmer, sensores, micro-dragado) seg\u00fan sitio. Marinas/hoteles que cuidan la experiencia visual del visitante. Servicio integral: recolecci\u00f3n + disposici\u00f3n y mantenimiento con OPEX bajo. Autodiagn\u00f3stico y mantenimiento predictivo (horas de motor, bater\u00edas) Universidades/labs ambientales que requieren campa\u00f1as de monitoreo con evidencia."},{"location":"rana/#value-proposition","title":"VALUE PROPOSITION","text":"<p>RANA mantiene limpios los cuerpos de agua con navegaci\u00f3n asistida y entrega evidencia medible (kg recolectados, m\u00b2 cubiertos, turbidez) para reducir quejas y justificar presupuesto con datos.</p>"},{"location":"rana/#costos-del-producto","title":"Costos del producto:","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"rana/#value-proposition_1","title":"VALUE PROPOSITION","text":"<p>RANA mantiene limpios los cuerpos de agua con navegaci\u00f3n asistida y entrega evidencia medible (kg recolectados, m\u00b2 cubiertos, turbidez) para reducir quejas y justificar presupuesto con datos.</p>"},{"location":"rana/#presentacion-del-producto","title":"Presentaci\u00f3n del producto:","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"rana/#documento-final","title":"Documento final","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"practicas/barrido/","title":"Barrido de LEDs","text":"<p>Esta pr\u00e1ctica consiste en implementar un barrido de LEDs en el Raspberry Pi Pico, donde cinco LEDs muestran un \u201c1\u201d que se desplaza de izquierda a derecha y de regreso (0\u21921\u21922\u21923\u21924\u21923\u21922\u21921\u2026), reforzando el uso de operaciones l\u00f3gicas y control de salidas digitales.  </p>"},{"location":"practicas/barrido/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Barrido de LEDs </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: Se program\u00f3 un barrido de LEDs controlados por el Raspberry Pi Pico. </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>C: Se utiliza el lenguaje C con el SDK de Raspberry Pi Pico, aprovechando librer\u00edas como pico/stdlib.h para el manejo de GPIO y retardos de tiempo. - Raspberry Pi Pico / Pico 2  </p>"},{"location":"practicas/barrido/#material-utilizado","title":"Material utilizado:","text":"<ul> <li>Cable micro-USB / USB-C para la programaci\u00f3n y alimentaci\u00f3n  </li> <li>Protoboard  </li> <li>5 LEDs de 5 mm o SMD  </li> <li>5 resistencias (220 \u03a9 \u2013 330 \u03a9) para limitar la corriente de los LEDs  </li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>Computadora con Visual Studio Code y el entorno Pico SDK configurado  </li> <li>Alimentaci\u00f3n (a trav\u00e9s del puerto USB del Pico)  </li> </ul>"},{"location":"practicas/barrido/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>Comprender el uso de salidas digitales en el microcontrolador Configurar pines GPIO del Raspberry Pi Pico como salidas para controlar LEDs.  </p> </li> <li> <p>Implementar un patr\u00f3n din\u00e1mico de iluminaci\u00f3n Mostrar un barrido secuencial donde un LED encendido se desplaza a lo largo de cinco posiciones y regresa.  </p> </li> <li> <p>Aplicar l\u00f3gica de control secuencial Usar variables de posici\u00f3n y direcci\u00f3n para generar el movimiento del \u201c1\u201d en el arreglo de LEDs.  </p> </li> <li> <p>Familiarizarse con retardos en sistemas embebidos Implementar pausas controladas para observar el movimiento del LED encendido.  </p> </li> <li> <p>Relacionar teor\u00eda con pr\u00e1ctica Visualizar c\u00f3mo las operaciones l\u00f3gicas permiten implementar un control din\u00e1mico de hardware.  </p> </li> </ul>"},{"location":"practicas/barrido/#3-circuito","title":"3) Circuito","text":"<p>La siguiente imagen muestra las conexiones realizadas, se utilizaron 5 resistencias de 220 ohms y 5 LEDs rojos.  </p> <p> </p> <p> </p>"},{"location":"practicas/barrido/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include \"pico/stdlib.h\"\n\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define LED4 4\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4))\n\nint main() {\n    stdio_init_all();\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);\n\n    int pos = 0;\n    int dir = 1; // 1 = derecha, -1 = izquierda\n\n    while (true) {\n        uint32_t value = (1u &lt;&lt; pos);\n        gpio_put_masked(LED_MASK, value);\n        sleep_ms(200);\n\n        pos += dir;\n\n        if (pos == 4) dir = -1; // extremo derecho\n        if (pos == 0) dir = 1;  // extremo izquierdo\n    }\n    return 0;\n}\n</code></pre>"},{"location":"practicas/barrido/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":"<ul> <li> <p>Definiciones y m\u00e1scara <pre><code>#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define LED4 4\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4))\n</code></pre> Se asignan los pines 0\u20134 para los LEDs. La m\u00e1scara permite inicializar y escribir en todos esos pines simult\u00e1neamente.</p> </li> <li> <p>Inicializaci\u00f3n <pre><code>gpio_init_mask(LED_MASK);\ngpio_set_dir_out_masked(LED_MASK);\n</code></pre> Los pines definidos se configuran como salida.</p> </li> <li> <p>Bucle principal <pre><code>uint32_t value = (1u &lt;&lt; pos);\ngpio_put_masked(LED_MASK, value);\n</code></pre> Solo el LED en la posici\u00f3n actual se enciende.</p> </li> </ul> <p>La variable dir controla la direcci\u00f3n del movimiento. Cuando llega al extremo derecho (LED4) cambia a izquierda, y al llegar al extremo izquierdo (LED0) cambia a derecha, logrando el efecto de ida y vuelta.</p>"},{"location":"practicas/inputs/","title":"Compuertas L\u00f3gicas con Botones y LED (Raspberry Pi Pico / Pico 2)","text":"<p>Implementaci\u00f3n de compuertas l\u00f3gicas (AND, OR, NOT, XOR, NAND, NOR) usando dos botones como entradas digitales y un LED como salida. Los botones usan pull-up interno (activos en bajo al presionar), y se incluye un debounce por software.</p>"},{"location":"practicas/inputs/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Compuertas L\u00f3gicas con GPIO </li> <li>Autor: Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 02/09/2025 </li> <li>Descripci\u00f3n breve: Se mapean dos entradas con botones a una salida LED que refleja la operaci\u00f3n l\u00f3gica seleccionada.</li> </ul> <p>Informaci\u00f3n del proyecto</p> <ul> <li>Lenguaje: C (Pico SDK)  </li> <li>MCU: Raspberry Pi Pico / Pico 2 (RP2040)  </li> <li>Librer\u00edas: <code>pico/stdlib.h</code>, <code>hardware/gpio.h</code> </li> <li>Entradas activas en: nivel bajo (por pull-up interno \u2192 al presionar = 0 l\u00f3gico)  </li> <li>Salida LED activa en: nivel alto</li> </ul>"},{"location":"practicas/inputs/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico / Pico 2  </li> <li>1 LED (salida) + 1 resistencia 220\u2013330 \u03a9  </li> <li>2 botones de pulso (entradas)  </li> <li>Cables, protoboard y cable USB  </li> <li>PC con VS Code + CMake + Pico SDK</li> </ul>"},{"location":"practicas/inputs/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar GPIO como entradas con <code>pull_up</code> y como salidas para LED.  </li> <li>Implementar compuertas l\u00f3gicas b\u00e1sicas con entradas discretas.  </li> <li>Manejar el rebote de botones por software de forma simple.  </li> <li>Proveer una base extensible para probar distintas compuertas.</li> </ul>"},{"location":"practicas/inputs/#3-circuito","title":"3) Circuito","text":"<ul> <li>Entradas (botones):</li> <li><code>BTN_A</code> \u2192 GPIO 14 \u2014 con <code>gpio_pull_up(BTN_A)</code> </li> <li><code>BTN_B</code> \u2192 GPIO 15 \u2014 con <code>gpio_pull_up(BTN_B)</code> </li> <li>El otro terminal de cada bot\u00f3n va a GND</li> <li>Salida (LED):</li> <li><code>LED_OUT</code> \u2192 GPIO 13  </li> <li>LED con resistencia en serie (220\u2013330 \u03a9), \u00e1nodo al GPIO y c\u00e1todo a GND (salida activa-alta)</li> <li>Tierra com\u00fan: compartir GND entre todos los elementos.  </li> </ul>"},{"location":"practicas/inputs/#4-codigo","title":"4) C\u00f3digo","text":"<p>Cambia <code>GATE_SELECTED</code> para elegir la compuerta a evaluar.</p> <p>```c</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n// ========= Mapeo de pines =========\n#define BTN_A    14\n#define BTN_B    15\n#define LED_OUT  13\n\n// ========= Selecci\u00f3n de compuerta =========\n// Opciones: AND, OR, NOT_A, XOR, NAND, NOR\ntypedef enum { AND, OR, NOT_A, XOR, NAND, NOR } gate_t;\n#define GATE_SELECTED AND   // &lt;- Cambia aqu\u00ed la compuerta a evaluar\n\n// ========= Par\u00e1metros de debounce =========\n#define DEBOUNCE_MS 20\nstatic absolute_time_t next_read_time = {0};\n\n// Lee bot\u00f3n con pull-up y entrega 0/1 l\u00f3gico (1 = presionado)\nstatic inline bool read_button_active_low(uint pin) {\n    // Con pull-up: gpio_get(pin) == 1 (no presionado), 0 (presionado)\n    return gpio_get(pin) ? 0 : 1;\n}\n\nstatic inline bool debounce_ready(void) {\n    return absolute_time_diff_us(get_absolute_time(), next_read_time) &lt;= 0;\n}\n\nstatic inline void debounce_arm(void) {\n    next_read_time = make_timeout_time_ms(DEBOUNCE_MS);\n}\n\nstatic bool logic_eval(gate_t gate, bool a, bool b) {\n    switch (gate) {\n        case AND:   return (a &amp;&amp; b);\n        case OR:    return (a || b);\n        case NOT_A: return (!a);        // ignora B\n        case XOR:   return (a ^ b);\n        case NAND:  return !(a &amp;&amp; b);\n        case NOR:   return !(a || b);\n        default:    return false;\n    }\n}\n\nint main(void) {\n    stdio_init_all();\n\n    // Configuraci\u00f3n de pines\n    gpio_init(LED_OUT);\n    gpio_set_dir(LED_OUT, true);\n    gpio_put(LED_OUT, 0);\n\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, false);\n    gpio_pull_up(BTN_A);\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, false);\n    gpio_pull_up(BTN_B);\n\n    debounce_arm();\n\n    while (true) {\n        if (!debounce_ready()) {\n            sleep_ms(1);\n            continue;\n        }\n\n        // Lectura de entradas (1 = presionado, 0 = suelto)\n        bool A = read_button_active_low(BTN_A);\n        bool B = read_button_active_low(BTN_B);\n\n        // Evaluaci\u00f3n l\u00f3gica\n        bool Y = logic_eval(GATE_SELECTED, A, B);\n\n        // Actualizar salida\n        gpio_put(LED_OUT, Y ? 1 : 0);\n\n        // Rearmar debounce\n        debounce_arm();\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"practicas/inputs/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/inputs/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>Cancha / Entradas: <code>BTN_A</code> (GPIO 14), <code>BTN_B</code> (GPIO 15), ambos con pull-up interno (activos en bajo).  </li> <li>Salida / Puntuaci\u00f3n: <code>LED_OUT</code> (GPIO 13), activo en alto (enciende con <code>1</code>).  </li> </ul>"},{"location":"practicas/inputs/#b-variables-clave-estado-del-juego","title":"b) Variables clave (estado del juego)","text":"<ul> <li>Entradas A, B: se leen con la funci\u00f3n <code>read_button_active_low()</code>, que invierte la l\u00f3gica de <code>gpio_get()</code> para que 1 = presionado.  </li> <li>Compuerta seleccionada: <code>GATE_SELECTED</code> de tipo <code>gate_t</code> (AND / OR / NOT_A / XOR / NAND / NOR).  </li> <li>Debounce: <code>DEBOUNCE_MS</code> define la ventana m\u00ednima entre lecturas estables.  </li> </ul>"},{"location":"practicas/inputs/#c-inicializacion-de-gpio-y-botones","title":"c) Inicializaci\u00f3n de GPIO y botones","text":"<ul> <li>LED como salida y en bajo al inicio (<code>gpio_put(LED_OUT, 0)</code>).  </li> <li>Botones como entrada con <code>gpio_pull_up()</code>.  </li> <li>La inversi\u00f3n l\u00f3gica se concentra en <code>read_button_active_low()</code> para mantener el c\u00f3digo limpio.  </li> </ul>"},{"location":"practicas/inputs/#d-bucle-principal","title":"d) Bucle principal","text":"<ul> <li>Cada DEBOUNCE_MS (20 ms por defecto) se muestrean A y B.  </li> <li>Se eval\u00faa <code>logic_eval(GATE_SELECTED, A, B)</code>.  </li> <li>Se escribe la salida en <code>LED_OUT</code>.  </li> </ul>"},{"location":"practicas/inputs/#e-tablas-de-verdad-referencia","title":"e) Tablas de verdad (referencia)","text":"<p>Supuesto: 1 = bot\u00f3n presionado; 0 = suelto.  </p> A B AND OR XOR NAND NOR 0 0 0 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 1 1 0 1 1 1 1 0 0 0 <p>Para NOT_A (usa solo A):</p> A NOT_A 0 1 1 0"},{"location":"practicas/inputs/#6-consideraciones-de-hardware","title":"6) Consideraciones de hardware","text":"<ul> <li>Resistencia del LED: 220\u2013330 \u03a9 en serie.  </li> <li>Botones con pull-up: el otro terminal a GND.  </li> <li>Com\u00fan de GND: imprescindible para referencia de niveles.  </li> <li>Rebotes: el debounce por soft (20 ms) suele ser suficiente. Si observas parpadeos, sube a 30\u201340 ms o a\u00f1ade filtro RC.  </li> <li>Polaridad del LED: si est\u00e1 invertido (c\u00e1todo al GPIO), deber\u00e1s invertir la l\u00f3gica de <code>gpio_put()</code>.  </li> </ul>"},{"location":"practicas/inputs/#video-de-demostracion","title":"Video de demostraci\u00f3n","text":""},{"location":"practicas/pong/","title":"Juego tipo \u201cPong\u201d con LEDs e interrupciones (Raspberry Pi Pico)","text":"<p>Esta pr\u00e1ctica implementa un \u201cPong\u201d lineal con 5 LEDs. Una \u201cpelota\u201d recorre de izquierda a derecha y viceversa (posiciones 1\u21945). Cada jugador tiene un bot\u00f3n: si lo presiona cuando la pelota llega a su extremo, cambia la direcci\u00f3n y \u201cdevuelve\u201d el tiro. Si nadie responde y la pelota \u201csale\u201d por un extremo, se marca punto: se enciende un LED de \u201canotaci\u00f3n\u201d del lado ganador durante 2 s y el juego reinicia desde el centro.  </p>"},{"location":"practicas/pong/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Pong de LEDs con interrupciones </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/09/2025 </li> <li>Descripci\u00f3n breve: Juego de \u201cPong\u201d unidimensional usando 5 LEDs para la pelota, 2 salidas para puntos y 2 botones con interrupciones para devolver la pelota en los extremos. </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>). T\u00e9cnicas clave: manejo de GPIO, interrupciones por flanco de bajada, pull-ups internos, l\u00f3gica de estados. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"practicas/pong/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) + cable micro-USB/USB-C  </li> <li>Protoboard  </li> <li>7 LEDs (5 para \u201ccancha\u201d, 2 para puntos J1/J2)  </li> <li>7 resistencias 220\u2013330 \u03a9 (una por LED)  </li> <li>2 botones moment\u00e1neos</li> <li>2 resistencias 1K-2K \u03a9 para los botones</li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>PC con VS Code + Pico SDK configurado  </li> </ul>"},{"location":"practicas/pong/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Usar interrupciones GPIO para leer botones con pull-up interno (activo en bajo).  </li> <li>Modelar la l\u00f3gica de juego con variables de posici\u00f3n (<code>pos</code>) y direcci\u00f3n (<code>dir</code>).  </li> <li>Indicar estado del juego en hardware: 5 LEDs para pelota, 2 salidas para \u201cpunto\u201d.  </li> <li>Practicar estructura de programa embebido (inicializaci\u00f3n\u2013ISR\u2013bucle principal).  </li> </ul>"},{"location":"practicas/pong/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Botones (activos en bajo): - Un terminal del bot\u00f3n a GND; el otro a GPIO 14 (BTN_AVANZA) y GPIO 15 (BTN_RETRO). Se habilita <code>gpio_pull_up()</code>, por lo que al presionar el bot\u00f3n, la l\u00ednea cae a 0 (flanco de bajada).</p> <p>LEDs \u201ccancha\u201d (con resistencia a GND): - <code>LED4 \u2192 GPIO 9</code> - <code>LED0 \u2192 GPIO 10</code> - <code>LED1 \u2192 GPIO 11</code> - <code>LED2 \u2192 GPIO 12</code> - <code>LED3 \u2192 GPIO 13</code></p> <p>LEDs de \u201cpunto\u201d (o zumbadores, seg\u00fan el montaje): - <code>J1 \u2192 GPIO 7</code> (punto del jugador izquierdo) - <code>J2 \u2192 GPIO 8</code> (punto del jugador derecho)</p> <p>Recomendaci\u00f3n: conectar \u00e1nodo del LED a GPIO mediante resistencia serie y c\u00e1todo a GND. Con <code>gpio_put(pin, 1)</code> el LED enciende.</p> <p>Tabla r\u00e1pida de pines</p> Se\u00f1al GPIO Uso BTN_AVANZA 14 Bot\u00f3n jugador izquierdo BTN_RETRO 15 Bot\u00f3n jugador derecho LED4 9 Posici\u00f3n 1 (extremo izq) LED0 10 Posici\u00f3n 2 LED1 11 Posici\u00f3n 3 (centro) LED2 12 Posici\u00f3n 4 LED3 13 Posici\u00f3n 5 (extremo der) J1 7 Indicador de punto izq J2 8 Indicador de punto der <p>Diagrama de conexi\u00f3n </p>"},{"location":"practicas/pong/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdbool.h&gt;\n\n#define BTN_AVANZA 14\n#define BTN_RETRO  15\n\n#define LED4 9\n#define LED0 10\n#define LED1 11\n#define LED2 12\n#define LED3 13\n#define J1 7\n#define J2 8\n\nbool Ju1 = false;   // estado bot\u00f3n jugador 1\nbool Ju2 = false;   // estado bot\u00f3n jugador 2\nint pos = 1;        // posici\u00f3n inicial de la pelota\nint dir = 1;        // direcci\u00f3n inicial: 1=derecha, -1=izquierda\n\nstatic void accion(uint gpio, uint32_t events) {\n    // FIX: habilitaste FALL en main; aqu\u00ed tambi\u00e9n revisa FALL y atiende ambos botones\n    if (events &amp; GPIO_IRQ_EDGE_FALL) {\n        if (gpio == BTN_AVANZA) { if (pos == 1 /*&amp;&amp; Ju1*/) dir = 1; }  // Ju1 opcional\n        if (gpio == BTN_RETRO)  { if (pos == 5 /*&amp;&amp; Ju2*/) dir = -1; } // Ju2 opcional\n    }\n    gpio_acknowledge_irq(gpio, events);\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint LEDS[5] = { LED4, LED0, LED1, LED2, LED3 };  // 9,10,11,12,13\n\n    for (int i = 0; i &lt; 5; i++) {                  // FIX: antes era &lt; 4\n        gpio_init(LEDS[i] );\n        gpio_set_dir(LEDS[i], true);\n        gpio_put(LEDS[i], 0);                      // FIX: apaga inicialmente\n    }\n\n    const uint PUNTOS[2] = { J1, J2 };\n    for (int i = 0; i &lt; 2; i++) {\n        gpio_init(PUNTOS[i] );                      // FIX: inicializa PUNTOS, no LEDS\n        gpio_set_dir(PUNTOS[i], true);              // FIX: salida\n        gpio_put(PUNTOS[i], 0);                     // FIX: apaga inicialmente\n    }\n\n    // Botones como entrada con pull-up (activo en bajo)\n    gpio_init(BTN_AVANZA); gpio_set_dir(BTN_AVANZA, false); gpio_pull_up(BTN_AVANZA);\n    gpio_init(BTN_RETRO);  gpio_set_dir(BTN_RETRO,  false); gpio_pull_up(BTN_RETRO);\n\n    // IRQ: instalas callback con el primero y habilitas tambi\u00e9n el segundo\n    gpio_set_irq_enabled_with_callback(BTN_AVANZA, GPIO_IRQ_EDGE_FALL, true, &amp;accion);\n    gpio_set_irq_enabled(BTN_RETRO,  GPIO_IRQ_EDGE_FALL, true);\n\n    while (true) {\n        // (Opcional) actualizar flags de botones si los quieres usar en otro lado\n        Ju1 = !gpio_get(BTN_AVANZA);\n        Ju2 = !gpio_get(BTN_RETRO);\n\n        // --- Movimiento autom\u00e1tico ---\n        pos += dir;\n\n        // Rebotes en bordes si nadie responde\n        if (pos == 6) {\n            for (int i = 0; i &lt; 5; i++) gpio_put(LEDS[i], 1);\n            gpio_put(J2, 1);\n            sleep_ms(2000);\n            gpio_put(J2, 0);\n            pos = 3;\n            // (tu l\u00f3gica original no reubica pos ni dir aqu\u00ed m\u00e1s all\u00e1 del if)\n        }\n\n        if (pos == 0) {\n            for (int i = 0; i &lt; 5; i++) gpio_put(LEDS[i], 1);\n            gpio_put(J1, 1);\n            sleep_ms(2000);\n            gpio_put(J1, 0);\n            pos = 3;\n        }\n\n        // --- Mostrar LEDs ---\n        for (int i = 0; i &lt; 5; i++) {\n            gpio_put(LEDS[i], (i + 1 == pos));     // LEDS[0] \u2194 pos=1 ... LEDS[4] \u2194 pos=5\n        }\n\n        sleep_ms(250);\n    }\n}\n</code></pre>"},{"location":"practicas/pong/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/pong/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>Botones: <code>BTN_AVANZA=14</code>, <code>BTN_RETRO=15</code> (entradas con pull-up, activos en bajo).</li> <li>LEDs \u201ccancha\u201d: <code>LED4=9</code>, <code>LED0=10</code>, <code>LED1=11</code>, <code>LED2=12</code>, <code>LED3=13</code>.   Se agrupan en <code>LEDS[5] = { LED4, LED0, LED1, LED2, LED3 }</code>, donde <code>pos=1</code> corresponde a <code>LEDS[0]</code> (GPIO 9) y <code>pos=5</code> a <code>LEDS[4]</code> (GPIO 13).</li> <li>Indicadores de punto: <code>J1=7</code> (izquierda), <code>J2=8</code> (derecha). Se configuran como salidas y se encienden 2 s al anotar.</li> </ul>"},{"location":"practicas/pong/#b-variables-de-estado","title":"b) Variables de estado","text":"<ul> <li><code>pos \u2208 {1,2,3,4,5}</code> indica la posici\u00f3n de la pelota.  </li> <li><code>dir \u2208 {+1, \u22121}</code> define la direcci\u00f3n (derecha/izquierda).  </li> <li><code>Ju1</code>, <code>Ju2</code> sirven como flags de lectura (opcionales, el juego funciona sin usarlas).</li> </ul>"},{"location":"practicas/pong/#c-interrupcion-accion","title":"c) Interrupci\u00f3n <code>accion()</code>","text":"<ul> <li>Se activa con flanco de bajada (<code>GPIO_IRQ_EDGE_FALL</code>) en cualquiera de los dos botones.</li> <li>L\u00f3gica de \u201cdevoluci\u00f3n\u201d:</li> <li>Si la pelota est\u00e1 en el extremo izquierdo (<code>pos==1</code>) y cae el bot\u00f3n izquierdo (<code>BTN_AVANZA</code>), se fuerza <code>dir = +1</code>.</li> <li>Si est\u00e1 en el extremo derecho (<code>pos==5</code>) y cae el bot\u00f3n derecho (<code>BTN_RETRO</code>), se fuerza <code>dir = \u22121</code>.</li> <li>Se llama a <code>gpio_acknowledge_irq()</code> para limpiar el evento atendido.</li> </ul>"},{"location":"practicas/pong/#d-inicializacion-en-main","title":"d) Inicializaci\u00f3n en <code>main()</code>","text":"<ul> <li><code>LEDS</code> y <code>PUNTOS</code> se inicializan como salidas y se apagan.  </li> <li>Botones se configuran como entradas con <code>gpio_pull_up()</code>.  </li> <li>Se registra la ISR con <code>gpio_set_irq_enabled_with_callback()</code> en <code>BTN_AVANZA</code> y se habilita tambi\u00e9n la IRQ de <code>BTN_RETRO</code>.</li> </ul>"},{"location":"practicas/pong/#e-bucle-principal","title":"e) Bucle principal","text":"<ul> <li>(Opcional) Actualiza <code>Ju1</code>/<code>Ju2</code> leyendo el estado instant\u00e1neo de los botones.  </li> <li>Movimiento: <code>pos += dir;</code> </li> <li>Punto/anotaci\u00f3n si la pelota \u201csale\u201d:</li> <li>Derecha: si <code>pos==6</code>, se encienden todos los LEDs de cancha, se activa <code>J2</code> por 2 s y se reinicia <code>pos=3</code>.</li> <li>Izquierda: si <code>pos==0</code>, se encienden todos los LEDs de cancha, se activa <code>J1</code> por 2 s y se reinicia <code>pos=3</code>. (La direcci\u00f3n <code>dir</code> no se reorienta expl\u00edcitamente tras el punto.)</li> <li>Render: se enciende \u00fanicamente el LED cuyo \u00edndice+1 == pos.</li> <li>Velocidad: <code>sleep_ms(250)</code> define la dificultad.</li> </ul>"},{"location":"practicas/pong/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Arranque: un \u00fanico LED encendido en la posici\u00f3n 1; la \u201cpelota\u201d avanza hacia la derecha (<code>dir=+1</code>).  </li> <li>Devoluci\u00f3n correcta: al llegar al LED extremo, si el jugador correspondiente presiona a tiempo, la pelota cambia de sentido sin salir.  </li> <li>Fallo: si nadie presiona y la pelota intenta pasar de <code>5\u21926</code> o <code>1\u21920</code>, se marca punto (<code>J2</code> o <code>J1</code>, respectivamente) y se reinicia en el centro (<code>pos=3</code>).  </li> </ul>"},{"location":"practicas/pong/#video-de-demostracion","title":"Video de demostraci\u00f3n","text":""},{"location":"practicas/secuencia/","title":"-Secuencia controlada","text":""},{"location":"practicas/secuencia/#direccion-de-secuenciaraspberry-pi-pico-pico-2","title":"Direcci\u00f3n de Secuencia(Raspberry Pi Pico / Pico 2)","text":"<p>Este proyecto implementa un controlador de la direcci\u00f3n de secuencia usando Raspberry Pi Pico. El sistema utiliza 5 LEDs para representar la cancha y 2 LEDs para la puntuaci\u00f3n. La \u201cpelota\u201d se mueve autom\u00e1ticamente en una direcci\u00f3n mediante un timer peri\u00f3dico; al llegar a un extremo, el controlador detiene la secuencia y espera la intervenci\u00f3n del jugador correspondiente a trav\u00e9s de interrupciones por bot\u00f3n. El controlador gestiona el cambio de direcci\u00f3n de la secuencia seg\u00fan la respuesta del jugador, reiniciando la pelota al centro si hay error y actualizando la puntuaci\u00f3n con los LEDs.</p>"},{"location":"practicas/secuencia/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Direcci\u00f3n de Secuencia </li> <li>Autor: Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 02/09/2025 </li> <li>Descripci\u00f3n breve: Direcci\u00f3n de Secuencia.</li> </ul> <p>Informaci\u00f3n del proyecto</p> <ul> <li>Lenguaje: C (Pico SDK)  </li> <li>MCU: Raspberry Pi Pico / Pico 2 (RP2040)  </li> <li>Librer\u00edas: <code>pico/stdlib.h</code>, <code>hardware/gpio.h</code>, <code>hardware/timer.h</code> </li> <li>Estrategia: Timer cada 500 ms mueve la pelota; en los extremos, se detiene y espera la IRQ del bot\u00f3n correcto.</li> </ul>"},{"location":"practicas/secuencia/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico / Pico 2  </li> <li>5 LEDs (cancha) + 2 LEDs (puntuaci\u00f3n)  </li> <li>7 resistencias 220\u2013330 \u03a9 (limitaci\u00f3n de corriente)  </li> <li>2 botones de pulso (Normally Open)  </li> <li>Cables, protoboard y cable USB  </li> <li>PC con VS Code + CMake + Pico SDK configurado</li> </ul>"},{"location":"practicas/secuencia/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Timers y concurrencia simple: Usar <code>repeating_timer</code> para l\u00f3gica peri\u00f3dica.  </li> <li>Interrupciones GPIO: Capturar eventos de bot\u00f3n sin bloquear el bucle principal.  </li> <li>M\u00e1quina de estados m\u00ednima: \u201cen marcha\u201d vs \u201cesperando respuesta en extremo\u201d.  </li> <li>Buenas pr\u00e1cticas de GPIO: Pull-ups, flancos adecuados y actualizaci\u00f3n clara de LEDs.  </li> <li>Retroalimentaci\u00f3n visual: Puntos con LEDs de score y reinicio al centro.</li> </ul>"},{"location":"practicas/secuencia/#3-circuito","title":"3) Circuito","text":"<ul> <li>Cancha (5 LEDs): GPIO 9\u201313 (cada uno con su resistencia a GND si el pin maneja nivel alto para encender).  </li> <li>Puntuaci\u00f3n: <code>LED_SCORE_P1</code> \u2192 GPIO 7, <code>LED_SCORE_P2</code> \u2192 GPIO 8.  </li> <li>Botones: <code>BTN_P1</code> \u2192 GPIO 14, <code>BTN_P2</code> \u2192 GPIO 15, ambos con pull-up interno; el otro terminal del bot\u00f3n a GND.  </li> <li>Alimentaci\u00f3n: v\u00eda USB del Pico.</li> </ul> <p>Con pull-up, el bot\u00f3n en reposo lee 1 y al presionar baja a 0. En este c\u00f3digo las IRQ est\u00e1n configuradas por flanco de subida (0x8u), es decir, al soltar.</p>"},{"location":"practicas/secuencia/#4-codigo","title":"4) C\u00f3digo","text":"<p>```c     #include      #include \"pico/stdlib.h\"     #include \"hardware/timer.h\"     #include \"hardware/gpio.h\" <pre><code>// Pines de LEDs de la cancha\n#define LED0 9\n#define LED1 10\n#define LED2 11\n#define LED3 12\n#define LED4 13\n\n// LEDs de puntuaci\u00f3n\n#define LED_SCORE_P1 7\n#define LED_SCORE_P2 8\n\n// Botones\n#define BTN_P1 14\n#define BTN_P2 15\n\n// Variables del juego\nvolatile int pelota_pos = 2;       // posici\u00f3n inicial (LED del centro)\nvolatile int direccion = 1;        // 1 \u2192 derecha, -1 \u2192 izquierda\nvolatile bool esperando_respuesta = false;\n\n// Prototipos\nbool mover_pelota(struct repeating_timer *t);\nvoid actualizar_leds();\nvoid btn_callback(uint gpio, uint32_t events);\n\nint main() {\n    stdio_init_all();\n\n    // Configuraci\u00f3n LEDs\n    int leds[] = {LED0, LED1, LED2, LED3, LED4, LED_SCORE_P1, LED_SCORE_P2};\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], true);\n        gpio_put(leds[i], 0);\n    }\n\n    // Configuraci\u00f3n botones\n    // Configuraci\u00f3n bot\u00f3n jugador 1\n    gpio_init(BTN_P1);\n    gpio_set_dir(BTN_P1, false);\n    gpio_pull_up(BTN_P1);\n\n    // Configuraci\u00f3n bot\u00f3n jugador 2\n    gpio_init(BTN_P2);\n    gpio_set_dir(BTN_P2, false);\n    gpio_pull_up(BTN_P2);\n\n    // Registrar el callback global UNA sola vez\n    gpio_set_irq_enabled_with_callback(BTN_P1, 0x8u, true, &amp;btn_callback);\n\n    // Habilitar interrupci\u00f3n tambi\u00e9n en el otro bot\u00f3n, sin registrar callback otra vez\n    gpio_set_irq_enabled(BTN_P2, 0x8u, true);\n\n    // Timer para mover la pelota\n    struct repeating_timer timer;\n    add_repeating_timer_ms(500, mover_pelota, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents(); // loop vac\u00edo, todo se maneja con interrupciones y timer\n    }\n}\n\n// Timer: mueve la pelota\nbool mover_pelota(struct repeating_timer *t) {\n    if (esperando_respuesta) return true; // espera al jugador\n\n    // Apagar LEDs\n    for (int i = LED0; i &lt;= LED4; i++) gpio_put(i, 0);\n\n    // Mover pelota\n    pelota_pos += direccion;\n\n    // Revisar si lleg\u00f3 al extremo\n    if (pelota_pos &lt;= 0) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 1\n        pelota_pos = 0;\n    } else if (pelota_pos &gt;= 4) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 2\n        pelota_pos = 4;\n    }\n\n    actualizar_leds();\n    return true;\n}\n\n// Encender LED de la pelota\nvoid actualizar_leds() {\n    gpio_put(LED0, pelota_pos == 0);\n    gpio_put(LED1, pelota_pos == 1);\n    gpio_put(LED2, pelota_pos == 2);\n    gpio_put(LED3, pelota_pos == 3);\n    gpio_put(LED4, pelota_pos == 4);\n}\n\n// Callback de botones (interrupciones)\nvoid btn_callback(uint gpio, uint32_t events) {\n    if (!esperando_respuesta) return;\n\n    if (gpio == BTN_P1 &amp;&amp; pelota_pos == 0) {\n        direccion = 1; // devuelve hacia la derecha\n        esperando_respuesta = false;\n    } \n    else if (gpio == BTN_P2 &amp;&amp; pelota_pos == 4) {\n        direccion = -1; // devuelve hacia la izquierda\n        esperando_respuesta = false;\n    } \n    else {\n        // Fall\u00f3 \u2192 punto para el contrario\n        if (gpio == BTN_P1) {\n            gpio_put(LED_SCORE_P2, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P2, 0);\n        } else {\n            gpio_put(LED_SCORE_P1, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P1, 0);\n        }\n        // Reiniciar pelota\n        pelota_pos = 2;\n        direccion = (gpio == BTN_P1) ? 1 : -1;\n        esperando_respuesta = false;\n    }\n    actualizar_leds();\n}\n</code></pre>"},{"location":"practicas/secuencia/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/secuencia/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>Cancha (LEDs de juego): <code>LED0..LED4</code> en GPIO 9\u201313. Representan la posici\u00f3n de la pelota en la cancha.  </li> <li>Puntuaci\u00f3n: <code>LED_SCORE_P1</code> (GPIO 7) y <code>LED_SCORE_P2</code> (GPIO 8). Se encienden brevemente cuando el jugador contrario gana un punto.  </li> <li>Botones: <code>BTN_P1</code> (GPIO 14) y <code>BTN_P2</code> (GPIO 15), configurados con pull-up interno (en reposo = 1, presionado = 0).  </li> </ul>"},{"location":"practicas/secuencia/#b-variables-clave","title":"b) Variables clave","text":"<ul> <li><code>pelota_pos \u2208 {0..4}</code>: indica qu\u00e9 LED de la cancha est\u00e1 encendido, es decir, la posici\u00f3n actual de la pelota.  </li> <li><code>direccion \u2208 {+1, \u22121}</code>: determina si la pelota se mueve hacia la derecha (+1) o hacia la izquierda (\u22121).  </li> <li><code>esperando_respuesta (bool)</code>: cuando la pelota llega a un extremo, el avance se pausa hasta que el jugador correspondiente presione su bot\u00f3n.  </li> </ul>"},{"location":"practicas/secuencia/#c-inicializacion-de-gpio-y-botones","title":"c) Inicializaci\u00f3n de GPIO y botones","text":"<ul> <li>Los LEDs de la cancha y de puntuaci\u00f3n se configuran como salida y se inicializan en apagado (<code>gpio_put(...,0)</code>).  </li> <li>Los botones se configuran como entrada con <code>gpio_pull_up()</code>.  </li> <li>Se registra un callback global con <code>gpio_set_irq_enabled_with_callback()</code> para BTN_P1.  </li> <li>Se habilita tambi\u00e9n la interrupci\u00f3n de BTN_P2 con <code>gpio_set_irq_enabled()</code>, pero sin registrar otro callback (se reutiliza el mismo).  </li> <li>Las interrupciones se configuran en flanco de subida (0x8u), es decir, cuando el bot\u00f3n pasa de presionado a liberado.  </li> </ul>"},{"location":"practicas/secuencia/#d-temporizador-repetitivo-repeating_timer","title":"d) Temporizador repetitivo (<code>repeating_timer</code>)","text":"<ul> <li>Se crea un temporizador con <code>add_repeating_timer_ms(500, mover_pelota, ...)</code>, que ejecuta la funci\u00f3n <code>mover_pelota</code> cada 500 ms.  </li> <li>Si <code>esperando_respuesta = false</code>, la pelota avanza (<code>pelota_pos += direccion</code>).  </li> <li>Si llega a los extremos (<code>0</code> o <code>4</code>), se fija <code>esperando_respuesta = true</code> y el juego queda en pausa hasta que un jugador responda.  </li> </ul>"},{"location":"practicas/secuencia/#e-funcion-actualizar_leds","title":"e) Funci\u00f3n <code>actualizar_leds()</code>","text":"<ul> <li>Se encarga de reflejar la posici\u00f3n actual de la pelota encendiendo \u00fanicamente el LED correspondiente (<code>LED0..LED4</code>) y apagando los dem\u00e1s.  </li> </ul>"},{"location":"practicas/secuencia/#f-callback-de-botones-btn_callback","title":"f) Callback de botones (<code>btn_callback</code>)","text":"<ul> <li>Solo act\u00faa si <code>esperando_respuesta = true</code>.  </li> <li>Caso correcto: </li> <li>Si la pelota est\u00e1 en el extremo izquierdo (<code>pelota_pos==0</code>) y se presiona BTN_P1, se cambia la direcci\u00f3n a derecha (<code>direccion=+1</code>) y se reanuda el juego.  </li> <li>Si la pelota est\u00e1 en el extremo derecho (<code>pelota_pos==4</code>) y se presiona BTN_P2, se cambia la direcci\u00f3n a izquierda (<code>direccion=-1</code>) y se reanuda el juego.  </li> <li>Caso incorrecto (falla): </li> <li>Si se presiona el bot\u00f3n equivocado, se enciende el LED de puntuaci\u00f3n del contrario durante 500 ms.  </li> <li>Despu\u00e9s, la pelota se reinicia al centro (<code>pelota_pos=2</code>) y la direcci\u00f3n inicial se ajusta seg\u00fan qui\u00e9n fall\u00f3.  </li> </ul>"},{"location":"practicas/secuencia/#g-maquina-de-estados-implicita","title":"g) M\u00e1quina de estados impl\u00edcita","text":"<ol> <li>RUNNING: la pelota avanza autom\u00e1ticamente cada 500 ms.  </li> <li>WAIT_INPUT: al llegar a un extremo, se detiene y espera la respuesta del jugador.  </li> <li>SCORE: si el jugador falla, se muestra el punto en el LED correspondiente, se reinicia la pelota en el centro y se regresa a RUNNING.  </li> </ol>"},{"location":"practicas/secuencia/#video-de-demostracion","title":"Video de demostraci\u00f3n","text":""},{"location":"practicas/sumador/","title":"Contador Binario de 4 Bits","text":"<p>Esta pr\u00e1ctica consiste en implementar un contador binario de 4 bits utilizando el Raspberry Pi Pico, donde cuatro LEDs muestran en tiempo real la representaci\u00f3n binaria de los n\u00fameros del 0 al 15. El objetivo es aplicar el uso de operaciones l\u00f3gicas y m\u00e1scaras para el control de salidas digitales y reforzar la comprensi\u00f3n del sistema binario..  </p>"},{"location":"practicas/sumador/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Contador Binario de 4 bits </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: Se programo un contador binario de cuatro bits.</li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>C: Se utiliza el lenguaje C con el SDK de Raspberry Pi Pico, aprovechando librer\u00edas como pico/stdlib.h para el manejo de GPIO y retardos de tiempo. - Raspberry Pi Pico / Pico 2  </p>"},{"location":"practicas/sumador/#material-utilizado","title":"Material utilizado:","text":"<ul> <li>Cable micro-USB / USB-C para la programaci\u00f3n y alimentaci\u00f3n  </li> <li>Protoboard  </li> <li>4 LEDs de 5 mm o SMD  </li> <li>4 resistencias (220 \u03a9 \u2013 330 \u03a9) para limitar la corriente de los LEDs  </li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>Computadora con Visual Studio Code y el entorno Pico SDK configurado  </li> <li>Alimentaci\u00f3n (a trav\u00e9s del puerto USB del Pico)  </li> </ul>"},{"location":"practicas/sumador/#1-objetivos","title":"1) Objetivos","text":"<ul> <li> <p>Objetivos de la pr\u00e1ctica</p> </li> <li> <p>Comprender el uso de salidas digitales en el microcontrolador Configurar los pines GPIO del Raspberry Pi Pico como salidas para controlar LEDs.</p> </li> <li> <p>Implementar un contador binario en hardware Representar en 4 LEDs la cuenta de 0 a 15, utilizando operaciones l\u00f3gicas y m\u00e1scaras para manipular bits.</p> </li> <li> <p>Aplicar l\u00f3gica de desplazamiento y enmascaramiento Utilizar operadores bit a bit (&lt;&lt;, &amp;, |) para mapear valores binarios a los pines seleccionados del microcontrolador.</p> </li> <li> <p>Familiarizarse con el control de tiempo en programas embebidos Manejar retardos en milisegundos para visualizar la secuencia del contador en los LEDs.</p> </li> <li> <p>Relacionar teor\u00eda con pr\u00e1ctica Observar c\u00f3mo los n\u00fameros en base binaria se traducen en encendidos y apagados de LEDs, reforzando el entendimiento de la representaci\u00f3n binaria en sistemas digitales.</p> </li> </ul>"},{"location":"practicas/sumador/#2-circuito","title":"2) Circuito","text":"<p>La siguiente imagen muestra las conexiones realizadas, se utilizaron 4 resistencias de 220 ohms y 4 leds rojos </p> <p></p> <p></p>"},{"location":"practicas/sumador/#3-codigo","title":"3) Codigo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#define A 12\n#define B 13    \n#define C 14\n#define D 15\n\nconst uint32_t LED_MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C) | (1u &lt;&lt; D) ;\n\n\nint main() {\n    stdio_init_all();\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);\n    gpio_put_masked(LED_MASK, 0);\n\n    while (true) {\n\n        for (uint32_t n = 0; n &lt; 16; n++) {\n            gpio_put_masked(LED_MASK, n&lt;&lt;12);\n            sleep_ms(1000);\n        } \n       /* gpio_put_masked(LED_MASK, LED_MASK);*/\n    }\n    return 0;\n}\n</code></pre>"},{"location":"practicas/sumador/#4-explicacion-del-programa","title":"4) Explicaci\u00f3n del programa","text":"<p>Explicaci\u00f3n del c\u00f3digo</p> <p>Este programa implementa un contador binario de 4 bits en un Raspberry Pi Pico usando los GPIO 12\u201315 para controlar cuatro LEDs.</p> <p>Definiciones y m\u00e1scara <pre><code>#define A 12\n#define B 13\n#define C 14\n#define D 15\n\nconst uint32_t LED_MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C) | (1u &lt;&lt; D);\n</code></pre></p> <p>Se asignan nombres a los pines.</p> <p>La m\u00e1scara (LED_MASK) permite configurar y escribir en todos los pines a la vez. <pre><code>Inicializaci\u00f3n\ngpio_init_mask(LED_MASK);\ngpio_set_dir_out_masked(LED_MASK);\ngpio_put_masked(LED_MASK, 0);\n</code></pre></p> <p>Inicializa los pines 12\u201315, los configura como salida y los apaga. <pre><code>Bucle principal\nfor (uint32_t n = 0; n &lt; 16; n++) {\n    gpio_put_masked(LED_MASK, n &lt;&lt; 12);\n    sleep_ms(1000);\n}\n</code></pre> Recorre los valores de 0 a 15 (0000\u20131111 en binario).</p> <p>n &lt;&lt; 12 alinea el n\u00famero con los GPIO 12\u201315.</p> <p>Cada segundo se actualiza el estado de los LEDs mostrando el conteo binario.</p>"},{"location":"practicas/sumador/#5-video-del-funcionamiento","title":"5) Video del Funcionamiento:","text":""},{"location":"practicas/sumador/#demostracion-en-video","title":"Demostraci\u00f3n en video","text":""},{"location":"practicas/PWM/control_pwm/","title":"Control de PWM","text":"Perif\u00e9ricos, Memoria, Ecosistema, Costos, Arquitectura y Velocidad de Trabajo"},{"location":"practicas/PWM/control_pwm/#informacion","title":"Informacion","text":"<ul> <li>Nombre del proyecto: Control de pwm con Raspberry Pico</li> <li>Equipo / Autor(es): Antonio Mart\u00ednez</li> <li>Curso / Asignatura: Sistemas Embebidos</li> <li>Fecha: 23/08/2025</li> <li>Descripci\u00f3n breve: Implementaci\u00f3n de un sistema de generaci\u00f3n de audio con buzzer pasivo usando control PWM en el microcontrolador RP2040 (Raspberry Pi Pico). Se documentan los perif\u00e9ricos utilizados y se ubica al RP2040 en una comparativa con otros MCUs.</li> </ul>"},{"location":"practicas/PWM/control_pwm/#introduccion-control-pwm","title":"Introducci\u00f3n: Control PWM","text":"<p>En este proyecto se emplea el m\u00f3dulo PWM (Pulse Width Modulation) del microcontrolador RASPBERRY PICO para generar se\u00f1ales de audio en un buzzer pasivo. El principio consiste en variar la frecuencia de la se\u00f1al cuadrada enviada al buzzer, de manera que \u00e9ste reproduzca diferentes notas musicales.  </p> <p>El c\u00f3digo define una lista de notas (frecuencias en Hz) y figuras r\u00edtmicas (divisiones de tiempo), que son enviadas al perif\u00e9rico PWM del RP2040 para reproducir una melod\u00eda.  </p> <p>Este enfoque demuestra c\u00f3mo los perif\u00e9ricos de un microcontrolador pueden ser usados no solo para control de motores o regulaci\u00f3n de voltaje, sino tambi\u00e9n para la generaci\u00f3n de sonidos y m\u00fasica digital.</p>"},{"location":"practicas/PWM/control_pwm/#perifericos","title":"Perif\u00e9ricos","text":"<ul> <li>RASPBERRY PICO     Se utiliza la Raspberry Pi Pico porque integra el microcontrolador RP2040, que cuenta con perif\u00e9ricos PWM de hardware dedicados. Esto permite generar se\u00f1ales de modulaci\u00f3n por ancho de pulso de manera precisa y eficiente, sin sobrecargar el procesador principal. Adem\u00e1s, la Pico es econ\u00f3mica, f\u00e1cil de programar y ampliamente soportada por la comunidad, lo que facilita el desarrollo y la depuraci\u00f3n de proyectos de control de se\u00f1ales como este.</li> </ul>"},{"location":"practicas/PWM/control_pwm/#ecosistema","title":"Ecosistema","text":"<p>El RP2040 cuenta con un ecosistema creciente y robusto:  </p> <ul> <li>Lenguajes soportados: C/C++ (usando SDK oficial) y MicroPython.  </li> <li>IDE y entornos comunes: VSCode, Thonny, Arduino IDE (con soporte agregado).  </li> </ul>"},{"location":"practicas/PWM/control_pwm/#velocidad-de-trabajo","title":"Velocidad de Trabajo","text":"<ul> <li>La Pico opera a 150 MHz, lo cual resulta sobrado para generar PWM de audio.  </li> <li>El c\u00e1lculo del divisor para el perif\u00e9rico PWM (<code>pwm_set_clkdiv_int_frac()</code>) se hace r\u00e1pidamente gracias a la alta frecuencia de reloj.  </li> <li>En este proyecto, la frecuencia m\u00e1xima usada fue ~2 kHz (notas musicales), muy por debajo del l\u00edmite real del microcontrolador.  </li> </ul>"},{"location":"practicas/PWM/control_pwm/#codigo-del-buzzer","title":"Codigo del buzzer","text":"<p>```c</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define BUZZER_PIN 15\n#define BPM 200           \n#define GAP_MS 12\n\n// notes en hz\n#define NOTE_B0  31\n#define NOTE_C1  33\n#define NOTE_CS1 35\n#define NOTE_D1  37\n#define NOTE_DS1 39\n#define NOTE_E1  41\n#define NOTE_F1  44\n#define NOTE_FS1 46\n#define NOTE_G1  49\n#define NOTE_GS1 52\n#define NOTE_A1  55\n#define NOTE_AS1 58\n#define NOTE_B1  62\n#define NOTE_C2  65\n#define NOTE_CS2 69\n#define NOTE_D2  73\n#define NOTE_DS2 78\n#define NOTE_E2  82\n#define NOTE_F2  87\n#define NOTE_FS2 93\n#define NOTE_G2  98\n#define NOTE_GS2 104\n#define NOTE_A2  110\n#define NOTE_AS2 117\n#define NOTE_B2  123\n#define NOTE_C3  131\n#define NOTE_CS3 139\n#define NOTE_D3  147\n#define NOTE_DS3 156\n#define NOTE_E3  165\n#define NOTE_F3  175\n#define NOTE_FS3 185\n#define NOTE_G3  196\n#define NOTE_GS3 208\n#define NOTE_A3  220\n#define NOTE_AS3 233\n#define NOTE_B3  247\n#define NOTE_C4  262\n#define NOTE_CS4 277\n#define NOTE_D4  294\n#define NOTE_DS4 311\n#define NOTE_E4  330\n#define NOTE_F4  349\n#define NOTE_FS4 370\n#define NOTE_G4  392\n#define NOTE_GS4 415\n#define NOTE_A4  440\n#define NOTE_AS4 466\n#define NOTE_B4  494\n#define NOTE_C5  523\n#define NOTE_CS5 554\n#define NOTE_D5  587\n#define NOTE_DS5 622\n#define NOTE_E5  659\n#define NOTE_F5  698\n#define NOTE_FS5 740\n#define NOTE_G5  784\n#define NOTE_GS5 831\n#define NOTE_A5  880\n#define NOTE_AS5 932\n#define NOTE_B5  988\n#define NOTE_C6  1047\n#define NOTE_CS6 1109\n#define NOTE_D6  1175\n#define NOTE_DS6 1245\n#define NOTE_E6  1319\n#define NOTE_F6  1397\n#define NOTE_FS6 1480\n#define NOTE_G6  1568\n#define NOTE_GS6 1661\n#define NOTE_A6  1760\n#define NOTE_AS6 1865\n#define NOTE_B6  1976\n\n#define REST 0\n\n// ====== Figuras (divisor del pulso) ======\n// Duraci\u00f3n real (ms) = (60000 / BPM) * 4 / FIG\n#define W   1   // redonda (4 tiempos)\n#define H   2   // blanca   (2 tiempos)\n#define Q   4   // negra    (1 tiempo)\n#define E   8   // corchea  (1/2)\n#define S   16  // semicor. (1/4)\n#define T32 32  // fusa\n\n// ====== PWM helper ======\nstatic void pwm_set_freq_duty(uint pin, uint32_t freq, float duty_percent) {\n    gpio_set_function(pin, GPIO_FUNC_PWM); // seteamos la funcion del pin a PWM\n    uint slice = pwm_gpio_to_slice_num(pin); //Cambiar la funcioin de GPIO a PWM\n    uint chan  = pwm_gpio_to_channel(pin); //Asignamos el canal\n\n    if (freq == 0) {\n        pwm_set_enabled(slice, false);\n        return;\n    }\n\n    //Aqui empezamos a calcular el divisor\n\n    uint32_t f_sys = 150000000u; // la frecuencia del pico\n    uint32_t top = 4095; // aqui pensamos esto para usar 12 bits, pues tenemos la formula log2(top +1)\n    float div = (float)f_sys / (freq * (top + 1));\n\n    //esto es solo por si se sale de rano el divisor\n    if (div &lt; 1.0f) div = 1.0f;          // l\u00edmite inferior ( pues solo tiene un rango el pwm de 1 a 255)\n    if (div &gt; 255.0f) div = 255.0f;      // l\u00edmite superior\n\n    uint32_t div_int  = (uint32_t)div; //dividimos div en su parte entera\n    uint32_t div_frac = (uint32_t)((div - div_int) * 16.0f); // y esta es su parte fraccionaria\n    //basicamente se define div que se usar\u00e1\n\n\n    pwm_set_clkdiv_int_frac(slice, div_int, div_frac); //seteamos el divisor, esta es como la funcion pwm_set_clkdiv pero con parte fraccionaria\n    pwm_set_wrap(slice, top);//seteamos el top\n\n    uint32_t level = (uint32_t)(duty_percent * 0.01f * (top + 1));\n    pwm_set_chan_level(slice, chan, level);\n    pwm_set_enabled(slice, true);\n}\n\nstatic inline uint32_t ms_per_whole(void) {\n    // para la duracion de una redonda \n    return (60000u / BPM) * 4u;\n}\n\nstatic void play(uint32_t freq, uint32_t figure_div) {\n    uint32_t dur_ms = ms_per_whole() / figure_div;\n    if (freq == REST) {\n        pwm_set_freq_duty(BUZZER_PIN, 0, 0);\n        sleep_ms(dur_ms);\n    } else {\n        pwm_set_freq_duty(BUZZER_PIN, freq, 50.0f);\n\n        sleep_ms(dur_ms);\n        pwm_set_freq_duty(BUZZER_PIN, 0, 0);\n\n    }\n}\n\n\nstatic const uint16_t melody[] = {\n    // Frase A\n    NOTE_D4, NOTE_D4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4, \n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //B\n    NOTE_C4, NOTE_C4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //C\n    NOTE_A3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //D \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n\n    //REPEAT 2\n    NOTE_D4, NOTE_D4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4, \n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //B\n    NOTE_C4, NOTE_C4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //C\n    NOTE_A3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //D \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n\n    //siguiente f   \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    // G\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //H\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //x2\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //H\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n\n\n\n\n\n};\n\nstatic const uint8_t rhythm[] = {\n    // Frase A\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    /// Frase B\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE C\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE D\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n\n    //REPEAT 2\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    /// Frase B\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE C\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE D\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //siguiente f   \n    E, E, Q,  \n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    // G\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //H\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //x2\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //H\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E\n\n\n\n\n\n};\n\n\n// ====== main ======\nint main() {\n    stdio_init_all();\n    gpio_init(BUZZER_PIN);\n    gpio_set_dir(BUZZER_PIN, true);\n\n    const int notes = sizeof(melody) / sizeof(melody[0]);\n\n    while (true) {\n        for (int i = 0; i &lt; notes; ++i) {\n            play(melody[i], rhythm[i]);\n        }\n        sleep_ms(800);  // breve pausa antes de repetir\n    }\n    return 0;\n}\n</code></pre>"},{"location":"practicas/PWM/control_pwm/#explicacion","title":"Explicaci\u00f3n","text":""},{"location":"practicas/PWM/control_pwm/#que-hace-playfreq-figure_div","title":"\u00bfQu\u00e9 hace <code>play(freq, figure_div)</code>?","text":"<p>Funci\u00f3n que toca una nota (o un silencio) en un buzzer mediante PWM durante el tiempo correspondiente a la figura r\u00edtmica.</p>"},{"location":"practicas/PWM/control_pwm/#parametros","title":"Par\u00e1metros","text":"<ul> <li><code>freq</code>: frecuencia de la nota en Hz. Si es <code>REST</code>, se reproduce silencio.</li> <li><code>figure_div</code>: divisor de la figura musical (1=redonda, 2=blanca, 4=negra, 8=corchea, etc.).</li> </ul>"},{"location":"practicas/PWM/control_pwm/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<ol> <li>Duraci\u00f3n: calcula <code>dur_ms = ms_per_whole() / figure_div</code>, usando el BPM para obtener la duraci\u00f3n de una redonda y dividirla por la figura indicada.</li> <li>Silencio (REST):</li> <li>Si <code>freq == REST</code>, apaga el PWM (<code>pwm_set_freq_duty(..., 0, 0)</code>) y espera <code>dur_ms</code>.</li> <li>Nota:</li> <li>Enciende el PWM con la frecuencia <code>freq</code> y duty 50% (<code>pwm_set_freq_duty(BUZZER_PIN, freq, 50.0f)</code>), generando una onda cuadrada sim\u00e9trica.</li> <li>Mantiene la nota con <code>sleep_ms(dur_ms)</code>.</li> <li>Apaga el PWM al final para garantizar silencio.</li> </ol>"},{"location":"practicas/PWM/control_pwm/#claves","title":"Claves","text":"<ul> <li>La frecuencia define el pitch (altura de la nota).</li> <li>El duty 50% ofrece buen equilibrio de volumen/timbre para un buzzer pasivo.</li> <li>Implementaci\u00f3n bloqueante: <code>sleep_ms(...)</code> detiene la CPU durante la nota/silencio.</li> <li>Versi\u00f3n m\u00ednima: no incluye micro-silencios de articulaci\u00f3n ni envolventes (ataque/decay).</li> </ul>"},{"location":"practicas/PWM/control_pwm/#referencias","title":"Referencias","text":""},{"location":"practicas/PWM/control_pwm/#video","title":"Video","text":"<ul> <li>Raspberry Pi Ltd. (2025). RP2040 Datasheet. Disponible en: https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html </li> <li>C\u00f3digo de pr\u00e1ctica en C (PWM con buzzer), desarrollado por el autor (2025).  </li> <li>Espressif Systems, STMicroelectronics, NXP, Microchip, Texas Instruments \u2013 Datasheets oficiales de referencia.  </li> </ul>"},{"location":"practicas/PWM/pwm_motor/","title":"Control de motor DC por PWM (3 velocidades) con botones (Raspberry Pi Pico + TB6612FNG)","text":"<p>Este proyecto controla la velocidad de un motor DC mediante PWM usando un Raspberry Pi Pico/Pico 2 y el driver TB6612FNG. Dos botones (SUBIR/BAJAR) cambian entre tres niveles de velocidad predefinidos. El PWM trabaja a 20 kHz (fuera del rango audible).</p>"},{"location":"practicas/PWM/pwm_motor/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Motor DC PWM 3 velocidades </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/10/2025 </li> <li>Descripci\u00f3n breve: Control de un motor DC con TB6612FNG usando PWM (20 kHz) y dos botones con _pull-up interno para seleccionar 3 niveles de velocidad (70%, 80%, 90%)._  </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/pwm.h</code>). T\u00e9cnicas clave: PWM (20 kHz), c\u00e1lculo de <code>clkdiv</code> y <code>wrap</code>, debounce por software, lectura de GPIO con pull-up y detecci\u00f3n de flanco. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"practicas/PWM/pwm_motor/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) y cable USB  </li> <li>Driver TB6612FNG </li> <li>Motor DC (compatible con la tensi\u00f3n de VM y corriente del driver)  </li> <li>Fuente de VM (ej. 5\u201312 V seg\u00fan motor)  </li> <li>2 botones moment\u00e1neos (a GND, sin resistencias externas gracias al pull-up interno)  </li> <li>Protoboard y jumpers</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM a 20 kHz sobre un pin GPIO para modular la velocidad del motor.  </li> <li>Implementar tres velocidades predefinidas con cambios mediante dos botones (subir/bajar).  </li> <li>Aplicar debounce por software y detecci\u00f3n de flanco 1\u21920.  </li> <li>Fijar direcci\u00f3n de giro con pines AIN1/AIN2 (TB6612FNG).</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Notas generales (TB6612FNG): - PWMA controla el canal A (ancho de pulso). - AIN1/AIN2 fijan la direcci\u00f3n del canal A. - AO1/AO2 salen al motor. - VM: alimentaci\u00f3n del motor (p. ej. 6\u201312 V). - VCC: 3V3 l\u00f3gicos desde el Pico. - GND com\u00fan entre Pico, TB6612 y la fuente del motor. - STBY: mantener en alto (3V3) para habilitar el driver.</p> <p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al (Pico) GPIO TB6612FNG Descripci\u00f3n <code>PWM_PIN</code> 0 PWMA PWM 20 kHz (control de velocidad) <code>DIR1_PIN</code> 16 AIN1 Direcci\u00f3n (bit 1) <code>DIR2_PIN</code> 17 AIN2 Direcci\u00f3n (bit 2) <code>BTN_DOWN_PIN</code> 2 \u2014 Bot\u00f3n BAJAR (a GND, pull-up) <code>BTN_UP_PIN</code> 3 \u2014 Bot\u00f3n SUBIR (a GND, pull-up) <p>Botones (activos en bajo): - Un terminal del bot\u00f3n a GND; el otro a GPIO 2 (BAJAR) o GPIO 3 (SUBIR). - Se habilita <code>gpio_pull_up()</code>, por lo que al presionar: 0 l\u00f3gico.</p> <p>Direcci\u00f3n fija (ejemplo): - <code>AIN1=1</code> y <code>AIN2=0</code> (definido en el c\u00f3digo) \u2192 giro adelante. - Para invertir el giro: intercambia los valores o cablea al rev\u00e9s.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"practicas/PWM/pwm_motor/#4-codigo","title":"4) C\u00f3digo","text":"<p>```c     // dc_motor_pwm.c \u2014 Control de motor DC con 3 velocidades (baja/media/alta)     // Raspberry Pi Pico / Pico 2 + TB6612FNG (ejemplo)     // PWM en GPIO15 \u2192 PWMA; Direcci\u00f3n: AIN1 (GPIO16), AIN2 (GPIO17)     // Botones a GND con pull-up interno: BTN_DOWN(GPIO13), BTN_UP(GPIO14)</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// ----------------- Pines -----------------\n#define PWM_PIN      0       // PWMA (TB6612)\n#define DIR1_PIN     16     // AIN1\n#define DIR2_PIN     17     // AIN2\n#define BTN_DOWN_PIN 2     // Bot\u00f3n: bajar velocidad\n#define BTN_UP_PIN   3     // Bot\u00f3n: subir velocidad\n\n// ----------------- PWM -------------------\n#define F_PWM_HZ  20000     // 20 kHz: fuera de audio\n#define TOP       1023      // 10 bits de resoluci\u00f3n (0..1023)\n\n// ----------------- Debounce --------------\n#define DEBOUNCE_MS 30\n\nint main() {\n    stdio_init_all();\n\n// --- Direcci\u00f3n: adelante (AIN1=1, AIN2=0) ---\ngpio_init(DIR1_PIN); gpio_set_dir(DIR1_PIN, GPIO_OUT); gpio_put(DIR1_PIN, 1);\ngpio_init(DIR2_PIN); gpio_set_dir(DIR2_PIN, GPIO_OUT); gpio_put(DIR2_PIN, 0);\n\n// --- Botones con pull-up interno (activos en 0) ---\ngpio_init(BTN_DOWN_PIN); gpio_set_dir(BTN_DOWN_PIN, GPIO_IN); gpio_pull_up(BTN_DOWN_PIN);\ngpio_init(BTN_UP_PIN);   gpio_set_dir(BTN_UP_PIN,   GPIO_IN); gpio_pull_up(BTN_UP_PIN);\n\n// --- PWM en el pin de control de velocidad ---\ngpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\nuint slice = pwm_gpio_to_slice_num(PWM_PIN);\nuint chan  = pwm_gpio_to_channel(PWM_PIN);\n\nfloat f_clk = 150000000.0f;                         // 125 MHz\nfloat div   = f_clk / (F_PWM_HZ * (TOP + 1));       // clkdiv flotante\npwm_set_clkdiv(slice, div);\npwm_set_wrap(slice, TOP);\n\npwm_set_chan_level(slice, chan, 0);                 // arranque detenido\npwm_set_enabled(slice, true);\n\n// --- Tabla de 3 velocidades (duty) ---\n// Baja=35%, Media=65%, Alta=90%\nuint16_t speed_levels[] = {\n    (uint16_t)(TOP * 0.70f),\n    (uint16_t)(TOP * 0.80f),\n    (uint16_t)(TOP * 0.90f)\n};\nconst int NUM_SPEEDS = 3;\n\nint idx = 0; // \u00edndice de velocidad actual (0=baja)\nuint32_t t_last_down = 0, t_last_up = 0;\nint last_down = 1, last_up = 1; // estados anteriores (con pull-up, reposo=1)\n\n// Aplica velocidad inicial\npwm_set_chan_level(slice, chan, speed_levels[idx]);\n\nwhile (true) {\n    // --- Leer botones (con edge + debounce) ---\n    int cur_down = gpio_get(BTN_DOWN_PIN);\n    int cur_up   = gpio_get(BTN_UP_PIN);\n    uint32_t now = to_ms_since_boot(get_absolute_time());\n\n    // Bot\u00f3n DOWN: flanco de 1-&gt;0\n    if (last_down == 1 &amp;&amp; cur_down == 0 &amp;&amp; (now - t_last_down) &gt; DEBOUNCE_MS) {\n        if (idx &gt; 0) idx--;\n        pwm_set_chan_level(slice, chan, speed_levels[idx]);\n        t_last_down = now;\n    }\n    // Bot\u00f3n UP: flanco de 1-&gt;0\n    if (last_up == 1 &amp;&amp; cur_up == 0 &amp;&amp; (now - t_last_up) &gt; DEBOUNCE_MS) {\n        if (idx &lt; (NUM_SPEEDS - 1)) idx++;\n        pwm_set_chan_level(slice, chan, speed_levels[idx]);\n        t_last_up = now;\n    }\n\n    last_down = cur_down;\n    last_up   = cur_up;\n\n    sleep_ms(5);\n}\n</code></pre> <p>}</p>"},{"location":"practicas/PWM/pwm_motor/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/PWM/pwm_motor/#a-configuracion-de-pwm-20-khz-10-bits","title":"a) Configuraci\u00f3n de PWM (20 kHz, 10 bits)","text":"<ul> <li><code>F_PWM_HZ = 20000</code> y <code>TOP = 1023</code> \u2192 resoluci\u00f3n de 10 bits (0..1023).</li> <li>Se calcula <code>clkdiv</code> con <code>div = f_clk / (F_PWM_HZ * (TOP + 1))</code>.</li> <li>Nota: En el c\u00f3digo <code>f_clk = 150e6</code> con comentario \u201c125 MHz\u201d. Ajusta el valor si tu reloj es 125 MHz (<code>125000000.0f</code>) o deja 150 MHz si realmente configuraste el PLL a esa frecuencia.</li> <li><code>pwm_set_wrap(slice, TOP)</code> y <code>pwm_set_clkdiv(slice, div)</code> fijan la frecuencia.</li> <li><code>pwm_set_chan_level(slice, chan, duty)</code> actualiza el ciclo de trabajo.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#b-direccion-del-motor-tb6612fng","title":"b) Direcci\u00f3n del motor (TB6612FNG)","text":"<ul> <li>Se fuerza adelante con <code>AIN1=1</code>, <code>AIN2=0</code>.</li> <li>Para invertir el giro: <code>AIN1=0</code>, <code>AIN2=1</code>. No uses <code>0/0</code> (rueda libre) ni <code>1/1</code> (freno) salvo intencionalmente.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#c-botones-con-pull-up-y-debounce","title":"c) Botones con pull-up y debounce","text":"<ul> <li><code>BTN_DOWN_PIN</code> (GPIO 2) y <code>BTN_UP_PIN</code> (GPIO 3) como entradas con <code>gpio_pull_up()</code>.</li> <li>Se detecta flanco 1\u21920 (presi\u00f3n) comparando estado previo/actual.</li> <li>Debounce: <code>DEBOUNCE_MS = 30</code> ms por bot\u00f3n con marcas de tiempo (<code>to_ms_since_boot</code>).</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#d-tabla-de-velocidades","title":"d) Tabla de velocidades","text":"<ul> <li>Niveles en <code>speed_levels[]</code>: 70%, 80%, 90% del <code>TOP</code>.</li> <li>Nota: El comentario dice \u201c35/65/90%\u201d, pero el c\u00f3digo actual aplica 70/80/90%. Cambia los coeficientes <code>0.70f, 0.80f, 0.90f</code> si deseas otros niveles (p. ej., <code>0.35f, 0.65f, 0.90f</code>).</li> <li><code>idx</code> selecciona el nivel. Los botones BAJAR/SUBIR decrementan/incrementan <code>idx</code> dentro de <code>[0, NUM_SPEEDS-1]</code>.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#e-bucle-principal","title":"e) Bucle principal","text":"<ul> <li>Lee botones, aplica debounce, actualiza <code>idx</code> si hay flanco v\u00e1lido y reprograma el duty con <code>pwm_set_chan_level</code>.</li> <li><code>sleep_ms(5)</code> fija la cadencia de sondeo (~200 Hz), suficiente para la interfaz de botones.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Arranque: motor en marcha a la velocidad 0 (70%).</li> <li>Bot\u00f3n SUBIR (GPIO 3): incrementa a 80% y luego 90%.</li> <li>Bot\u00f3n BAJAR (GPIO 2): decrementa hacia 80% y 70%.</li> <li>Debounce estable: pulsaciones r\u00e1pidas no deben generar m\u00faltiples cambios espurios.</li> <li>Silencio el\u00e9ctrico: PWM a 20 kHz evita zumbidos audibles en la mayor\u00eda de motores.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/","title":"Senoide aproximada de 60 Hz por PWM (Raspberry Pi Pico)","text":"<p>Este proyecto genera una se\u00f1al senoidal \u201cpromediada\u201d de 60 Hz modulando el duty cycle de una portadora PWM a 40 kHz (10 bits). Se actualiza el duty en 128 muestras por ciclo, logrando un valor medio (tras filtrado o por inercia de la carga) que sigue una senoide. \u00datil para pruebas de filtrado RC, control de potencia (baja tensi\u00f3n) o caracterizaci\u00f3n de etapas H-bridge (aisladas). No conectar a la red el\u00e9ctrica.</p>"},{"location":"practicas/PWM/seno_pwm/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: PWM \u2192 senoide de 60 Hz </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/10/2025 </li> <li>Descripci\u00f3n breve: S\u00edntesis de una senoide de 60 Hz mediante modulaci\u00f3n del duty de un PWM a 40 kHz con 10 bits y 128 muestras por ciclo. Timing con <code>sleep_until()</code> para reducir jitter. </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>pico/time.h</code>, <code>hardware/pwm.h</code>). T\u00e9cnicas clave: PWM de alta frecuencia, tabla/muestreo senoidal, temporizaci\u00f3n absoluta (bajo jitter), cuantizaci\u00f3n 10 bits. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"practicas/PWM/seno_pwm/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) y cable USB  </li> <li>Protoboard y jumpers  </li> <li>(Opcional) Filtro RC pasabajas (p. ej., R=1\u20134.7 k\u03a9, C=4.7\u201310 \u00b5F) para recuperar la senoide promedio  </li> <li>(Opcional) Osciloscopio para visualizar portadora y se\u00f1al filtrada  </li> <li>(Si se usa potencia) Etapa H-bridge/l\u00ednea aislada, nunca a red AC</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM a 40 kHz con 10 bits de resoluci\u00f3n.  </li> <li>Generar una senoide de 60 Hz modulando el duty con 128 muestras/ciclo.  </li> <li>Usar temporizaci\u00f3n absoluta (<code>sleep_until</code>) para minimizar jitter de muestreo.  </li> <li>Controlar amplitud (<code>AMP_PCT</code>) y offset DC (<code>DC_OFFSET</code>) de la se\u00f1al promediada.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al (Pico) GPIO Descripci\u00f3n <code>PWM_PIN</code> 15 Salida PWM (portadora 40 kHz, duty variable) <code>GND</code> \u2014 Referencia com\u00fan <p>Notas de conexi\u00f3n: - Para observar la senoide promedio, conecta <code>PWM_PIN</code> a un filtro RC pasabajas y mide en la salida del filtro respecto a GND. - Ajusta el corte del RC (p. ej., 300\u2013800 Hz) para atenuar la portadora (40 kHz) preservando 60 Hz.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"practicas/PWM/seno_pwm/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>```c\n// pwm_sine_60hz.c \u2014 Senoide aproximada de 60 Hz modulando el duty del PWM\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWM_PIN             15      // GPIO de salida PWM\n#define F_PWM_HZ            40000   // Portadora PWM (40 kHz, fuera de audio)\n#define TOP                 1023    // 10 bits de resoluci\u00f3n\n\n#define SINE_FREQ_HZ        60      // Frecuencia de la senoide \u201cpromediada\u201d\n#define SAMPLES_PER_CYCLE   128     // Muestras por ciclo de seno\n#define AMP_PCT             0.98f   // Amplitud relativa (0..1)\n#define DC_OFFSET           0.50f   // Offset DC relativo (0.5 = centrado)\n\nint main() {\n    stdio_init_all();\n\n    // --- Configurar PWM en el pin ---\n    gpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(PWM_PIN);\n\n    // Calcular divisor para la portadora\n    float f_clk = 125000000.0f;                    // 125 MHz\n    float div   = f_clk / (F_PWM_HZ * (TOP + 1));  // clkdiv flotante\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // --- Generaci\u00f3n de seno por software (duty = sin()) ---\n    const float fs = (float)SINE_FREQ_HZ * (float)SAMPLES_PER_CYCLE;   // tasa de actualizaci\u00f3n\n    const uint32_t Ts_us = (uint32_t)lrintf(1000000.0f / fs);          // periodo de muestreo en us\n\n    float phase = 0.0f;\n    const float phase_step = 2.0f * (float)M_PI / (float)SAMPLES_PER_CYCLE;\n\n    // Reloj base para minimizar jitter\n    absolute_time_t t = delayed_by_us(get_absolute_time(), Ts_us);\n\n    while (true) {\n        // s \u2208 [-1,1] \u2192 u \u2208 [0,1] con offset y amplitud\n        float s = sinf(phase);\n        float u = DC_OFFSET + 0.5f * AMP_PCT * s;\n        if (u &lt; 0.0f) u = 0.0f; if (u &gt; 1.0f) u = 1.0f;\n\n        uint16_t level = (uint16_t)lrintf(u * (float)TOP);\n        pwm_set_chan_level(slice, chan, level);\n\n        // Avanzar fase y temporizaci\u00f3n precisa\n        phase += phase_step;\n        if (phase &gt;= 2.0f * (float)M_PI) phase -= 2.0f * (float)M_PI;\n\n        sleep_until(t);\n        t = delayed_by_us(t, Ts_us);\n    }\n}\n</code></pre>"},{"location":"practicas/PWM/seno_pwm/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/PWM/seno_pwm/#a-portadora-pwm-40-khz-10-bits","title":"a) Portadora PWM (40 kHz, 10 bits)","text":"<ul> <li><code>F_PWM_HZ = 40000</code> y <code>TOP = 1023</code> \u2192 10 bits (niveles 0..1023).</li> <li>Frecuencia de PWM mediante <code>div = f_clk / (F_PWM_HZ*(TOP+1))</code> con <code>f_clk = 125 MHz</code>.</li> <li><code>pwm_set_wrap(slice, TOP)</code> define el conteo y <code>pwm_set_clkdiv(slice, div)</code> ajusta el preescalador.</li> <li>El duty se actualiza con <code>pwm_set_chan_level(slice, chan, level)</code>.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#b-senoide-promedio-de-60-hz-muestreo-a-768-khz","title":"b) Senoide \u201cpromedio\u201d de 60 Hz (muestreo a 7.68 kHz)","text":"<ul> <li><code>SINE_FREQ_HZ = 60</code>, <code>SAMPLES_PER_CYCLE = 128</code> \u2192 <code>fs = 60\u00d7128 = 7680 Hz</code>.</li> <li>Periodo de muestra: <code>Ts_us \u2248 1e6 / 7680 \u2248 130.21 \u00b5s</code> (redondeado con <code>lrintf</code>).</li> <li>Se incrementa la fase en <code>phase_step = 2\u03c0/128</code> por muestra y se calcula <code>u = DC_OFFSET + 0.5\u00b7AMP_PCT\u00b7sin(phase)</code> limitado a <code>[0,1]</code>.</li> <li><code>u</code> se mapea a 10 bits: <code>level = round(u\u00b7TOP)</code>.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#c-temporizacion-precisa-bajo-jitter","title":"c) Temporizaci\u00f3n precisa (bajo jitter)","text":"<ul> <li>Se emplea un reloj absoluto: <code>sleep_until(t); t = delayed_by_us(t, Ts_us);</code> en vez de <code>sleep_us(Ts_us)</code>.</li> <li>Esto mantiene un periodo constante de actualizaci\u00f3n de duty, reduciendo el jitter de muestreo.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#d-control-de-amplitud-y-offset","title":"d) Control de amplitud y offset","text":"<ul> <li><code>AMP_PCT</code> (0..1) escala la amplitud pico a pico de la senoide promedio (aqu\u00ed 98%).</li> <li><code>DC_OFFSET = 0.5</code> centra la se\u00f1al en 50% de duty (salida bipolar tras filtro/etapa diferencial).</li> <li>Para una salida puramente unipolar filtrada, mantiene <code>DC_OFFSET \u2265 AMP_PCT/2</code>.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#e-recuperacion-de-la-senoide-filtro","title":"e) Recuperaci\u00f3n de la senoide (filtro)","text":"<ul> <li>Para observar una senoide limpia, usa un filtro pasabajas (p. ej., RC con <code>fc\u2248300\u2013800 Hz</code>).</li> <li>La portadora a 40 kHz queda muy atenuada; se conserva la envolvente de 60 Hz.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Osciloscopio (PWM crudo): tren a 40 kHz cuyo duty va oscilando suavemente.</li> <li>Tras RC: se\u00f1al aproximada a senoide 60 Hz; amplitud depende de <code>AMP_PCT</code>, offset seg\u00fan <code>DC_OFFSET</code>.</li> <li>Estabilidad temporal: la frecuencia de 60 Hz es estable por el uso de <code>sleep_until</code>.</li> <li>Ajustes r\u00e1pidos: cambiar <code>SAMPLES_PER_CYCLE</code> mejora la suavidad (m\u00e1s muestras) a costa de mayor tasa de actualizaci\u00f3n.</li> </ul>"},{"location":"practicas/temporizadores/comparativa/","title":"Comparativa de codigos optimizados","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"practicas/temporizadores/comparativa/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Blink con temporizador (alto y bajo nivel) en Raspberry Pi Pico  </li> <li>Autor: Antonio Martinez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 10/09/2025 </li> <li>Descripci\u00f3n breve: Implementaci\u00f3n y comparaci\u00f3n de dos enfoques para parpadear un LED en la Raspberry Pi Pico: (1) SDK de alto nivel con <code>add_repeating_timer_ms</code> y (2) bajo nivel programando ALARM0 e IRQ del perif\u00e9rico TIMER.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"practicas/temporizadores/comparativa/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Evaluar precisi\u00f3n, simplicidad y control de dos m\u00e9todos de temporizaci\u00f3n (alto vs. bajo nivel) para el parpadeo de un LED en la Pico.</li> <li>Espec\u00edficos:</li> <li>Implementar un parpadeo con timer de alto nivel (SDK).</li> <li>Implementar un parpadeo con timer de sistema + ALARM0 + IRQ.</li> <li>Comparar periodo efectivo y estabilidad de ambos enfoques mediante mediciones/observaciones.</li> <li>Documentar configuraci\u00f3n, c\u00f3digo y resultados.</li> </ul>"},{"location":"practicas/temporizadores/comparativa/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:</li> <li>C\u00f3digo C para Pico (RP2040/RP2350).</li> <li>Explicaciones de configuraci\u00f3n GPIO y temporizadores.</li> <li>F\u00f3rmulas de periodo/frecuencia y tabla de par\u00e1metros.</li> <li> <p>Secciones para insertar capturas/mediciones.</p> </li> <li> <p>No incluye:</p> </li> <li>Medidas con instrumentos espec\u00edficos (osciloscopio/analizador l\u00f3gico) (pueden anexarse como evidencia).</li> <li>Optimizaci\u00f3n avanzada de latencia fuera del alcance did\u00e1ctico.</li> </ul>"},{"location":"practicas/temporizadores/comparativa/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Pico SDK (v1.x\u2013v2.x) - CMake (\u2265 3.13) - Toolchain GCC ARM (ej. <code>arm-none-eabi-gcc</code>) - <code>picotool</code> (opcional, para flasheo) - Git</p> <p>Hardware - Raspberry Pi Pico / Pico 2 (RP2040/RP2350) - LED en GP15 (si tu placa no trae LED en ese pin) + resistencia (220\u20131k\u03a9) - Osiloscopio</p> <p>Conocimientos previos - C b\u00e1sico - Electr\u00f3nica digital b\u00e1sica (GPIO, resistencias) - Flujo de compilaci\u00f3n con Pico SDK</p>"},{"location":"practicas/temporizadores/comparativa/#5-codigo-1-y-resultados","title":"5) Codigo 1 y resultados","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 15              // &lt;-- usar GPIO 15 (GP15)\nstatic const int BLINK_MS = 250;\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true;\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);  // mejor usar GPIO_OUT que true\n\n    repeating_timer_t timer;\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>Resultados </p>"},{"location":"practicas/temporizadores/comparativa/#6-codigo-2-y-resultados","title":"6) Codigo 2 y resultados","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN 15    \n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 250000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>Resultados </p>"},{"location":"practicas/temporizadores/comparativa/#7-comparativa-y-conclusiones","title":"7) Comparativa y conclusiones","text":"<p>Resumen de la medici\u00f3n. Con ambos programas configurados para conmutar cada 250 ms, se observ\u00f3 una diferencia de 0.1 ms a favor del enfoque de bajo nivel (ALARM0 + IRQ), es decir, el de bajo nivel fue ligeramente m\u00e1s r\u00e1pido.</p> M\u00e9todo (T_{\\text{toggle}}) medido Desviaci\u00f3n vs 250 ms Comentario breve Alto nivel (repeating_timer) 250.1 ms +0.1 ms Despacho mediante callback del SDK Bajo nivel (ALARM0 + IRQ) 250.0 ms 0.0 ms Programaci\u00f3n directa de alarma + <code>sio_hw-&gt;gpio_togl</code> <p>Interpretaci\u00f3n. - El alto nivel introduce una peque\u00f1a latencia por la capa de abstracci\u00f3n (gesti\u00f3n del callback, comprobaciones internas), lo que explica el retardo adicional de ~0.1 ms. - El bajo nivel programa el \u201cdeadline\u201d en el temporizador de hardware y conmuta el pin v\u00eda SIO (<code>sio_hw-&gt;gpio_togl</code>) dentro de la ISR, reduciendo el overhead y la deriva acumulada.</p> <p>Conclusiones pr\u00e1cticas. - Para aplicaciones did\u00e1cticas o de prototipado, el enfoque alto nivel es suficiente y m\u00e1s legible. - Para requisitos de precisi\u00f3n temporal o ventanas largas (minimizando deriva/jitter), el enfoque bajo nivel es preferible. - Aunque la diferencia medida (0.1 ms) es peque\u00f1a, confirma que la ruta ALARM0 + IRQ ofrece mejor control temporal con el mismo par\u00e1metro nominal.</p> <p>Notas de medici\u00f3n. - Asegurar condiciones comparables (misma alimentaci\u00f3n, misma carga en el pin y entorno) y, si es posible, repetir varias veces y reportar promedio y desviaci\u00f3n. - El contador de 32 bits del TIMER \u201cenvuelve\u201d ~cada 71.6 min; el uso de deadline acumulativo mantiene el ritmo al pasar por el wrap-around.</p>"},{"location":"practicas/temporizadores/temporizadores/","title":"-control de LEDs","text":""},{"location":"practicas/temporizadores/temporizadores/#parpadeo-de-4-leds-con-system-timer-rp2350-pico-2","title":"Parpadeo de 4 LEDs con System Timer (RP2350 / Pico 2)","text":"<p>Resumen</p> <p>Este programa usa las 4 hardware alarms del temporizador de sistema para hacer parpadear 4 LEDs de manera independiente, programando cada pr\u00f3ximo \u201cdeadline\u201d en microsegundos dentro de cada ISR (interrupt service routine). Es un enfoque sin bloqueo: todo el parpadeo ocurre en las ISRs; el <code>while(true)</code> queda libre.</p>"},{"location":"practicas/temporizadores/temporizadores/#objetivo","title":"Objetivo","text":"<ul> <li>Controlar 4 LEDs con periodos distintos usando ALARM0..ALARM3 del perif\u00e9rico <code>timer</code>.</li> <li>Trabajar en microsegundos (timebase de 1 MHz).</li> <li>Mantener precisi\u00f3n temporal reprogramando el siguiente disparo desde el deadline previo (evita drift).</li> </ul>"},{"location":"practicas/temporizadores/temporizadores/#plataforma-y-dependencias","title":"Plataforma y dependencias","text":"<ul> <li>MCU: RP2350 (Raspberry Pi Pico 2)  </li> <li>SDK: Raspberry Pi Pico SDK  </li> <li>Headers: <code>pico/stdlib.h</code>, <code>hardware/irq.h</code>, <code>hardware/structs/timer.h</code>, <code>hardware/gpio.h</code></li> </ul>"},{"location":"practicas/temporizadores/temporizadores/#mapa-de-pines-y-alarmas","title":"Mapa de pines y alarmas","text":"Recurso Definici\u00f3n Uso en c\u00f3digo LED0 <code>LED0_PIN = 12</code> Parpadeo con ALARM0 LED1 <code>LED1_PIN = 13</code> Parpadeo con ALARM1 LED2 <code>LED2_PIN = 14</code> Parpadeo con ALARM2 LED3 <code>LED3_PIN = 15</code> Parpadeo con ALARM3 ALARM0 <code>ALARM0_NUM = 0</code> IRQ <code>ALARM0_IRQ</code> \u2192 <code>on_alarm0_irq()</code> ALARM1 <code>ALARM1_NUM = 1</code> IRQ <code>ALARM1_IRQ</code> \u2192 <code>on_alarm1_irq()</code> ALARM2 <code>ALARM2_NUM = 2</code> IRQ <code>ALARM2_IRQ</code> \u2192 <code>on_alarm2_irq()</code> ALARM3 <code>ALARM3_NUM = 3</code> IRQ <code>ALARM3_IRQ</code> \u2192 <code>on_alarm3_irq()</code> <p>Nota: Asegura que los comentarios de pines coinciden con los <code>#define</code> usados.</p>"},{"location":"practicas/temporizadores/temporizadores/#periodos-y-frecuencias","title":"Periodos y frecuencias","text":"<p>Los intervalos est\u00e1n en \u00b5s:</p> <ul> <li><code>INTERVALO0_US = 250000</code> \u2192 0.25 s \u2192 4 Hz</li> <li><code>INTERVALO1_US = 500000</code> \u2192 0.50 s \u2192 2 Hz</li> <li><code>INTERVALO2_US = 750000</code> \u2192 0.75 s \u2192 1.33 Hz</li> <li><code>INTERVALO3_US = 1000000</code> \u2192 1.00 s \u2192 1 Hz</li> </ul> <p>Cambia estas constantes para ajustar la velocidad de cada LED.</p>"},{"location":"practicas/temporizadores/temporizadores/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<ol> <li>Inicializaci\u00f3n de GPIOs: <code>gpio_init()</code>, <code>gpio_set_dir(..., GPIO_OUT)</code> y <code>gpio_put(..., 0)</code> por LED.  </li> <li>Base de tiempo: <code>timer_hw-&gt;source = 0u;</code> (1 MHz \u2192 1 \u00b5s por tick).  </li> <li>Captura \u201cahora\u201d: <code>now_us = timer_hw-&gt;timerawl;</code> (32 bits bajos).  </li> <li>Deadlines iniciales: <code>nextX_us = now_us + INTERVALOX_US</code> (X=0..3).  </li> <li>Programaci\u00f3n de alarmas: <code>timer_hw-&gt;alarm[ALARMX_NUM] = nextX_us</code>.  </li> <li>ISRs registradas y IRQs habilitadas.  </li> <li>Bucle principal: <code>tight_loop_contents();</code> (sin trabajo, todo ocurre en ISRs).</li> </ol>"},{"location":"practicas/temporizadores/temporizadores/#rutinas-de-interrupcion-isrs","title":"Rutinas de interrupci\u00f3n (ISRs)","text":"<p>Cada ISR:</p> <ul> <li>Limpia su flag: <code>hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMX_NUM);</code></li> <li>Conmuta el pin: <code>sio_hw-&gt;gpio_togl = 1u &lt;&lt; LEDX_PIN;</code></li> <li>Reagenda desde el deadline: <code>nextX_us += INTERVALOX_US;</code></li> <li>Reprograma su alarma: <code>timer_hw-&gt;alarm[ALARMX_NUM] = nextX_us;</code></li> </ul> <p>Reagendar desde el deadline previo evita el drift que ocurrir\u00eda si se usara el \u201ctiempo actual\u201d.</p>"},{"location":"practicas/temporizadores/temporizadores/#consideraciones-de-temporizacion","title":"Consideraciones de temporizaci\u00f3n","text":"<ul> <li>Rollover 32 bit: <code>timerawl</code>/<code>nextX_us</code> envuelven cada \u2248 71.58 min (2^32 \u00b5s). El esquema por deadlines lo maneja bien si todo se mantiene en 32 bits.  </li> <li>SIO toggle: Requiere GPIO en funci\u00f3n SIO (por defecto tras <code>gpio_init()</code>). Es at\u00f3mico y r\u00e1pido.  </li> <li>ISRs ligeras: Evita trabajo pesado dentro de interrupciones.</li> </ul>"},{"location":"practicas/temporizadores/temporizadores/#codigo","title":"codigo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     12   // LED integrado\n#define LED1_PIN     13                      // LED externo en GPIO 0\n#define LED2_PIN     14   // LED integrado\n#define LED3_PIN     15\n\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\n\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n#define ALARM3_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM3_NUM)\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us,next2_us,next3_us;\nstatic const uint32_t INTERVALO0_US = 250000u;\nstatic const uint32_t INTERVALO1_US = 500000u;\nstatic const uint32_t INTERVALO2_US = 750000u;\nstatic const uint32_t INTERVALO3_US = 1000000u;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\nstatic void on_alarm3_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM3_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n    next3_us += INTERVALO3_US;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n}\n\n\n\n\nint main() {\n\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n\n    gpio_init(LED3_PIN);\n    gpio_set_dir(LED3_PIN, GPIO_OUT);\n    gpio_put(LED3_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    // Programa ambas alarmas\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next3_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n    irq_set_exclusive_handler(ALARM3_IRQ, on_alarm3_irq);\n\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Habilita ambas IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n    irq_set_enabled(ALARM3_IRQ, true);\n\n    // Bucle principal: todo el parpadeo ocurre en las ISRs\n    while (true) {\n        tight_loop_contents();\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre>"},{"location":"practicas/uart/Examen/","title":"Control de Servomotor con Lista de \u00c1ngulos y 3 Modos (Raspberry Pi Pico / Pico 2)","text":"<p>Programa para grabar, reproducir y navegar una lista de \u00e1ngulos (0\u2013180\u00b0) para un servomotor usando PWM en el RP2040. La interfaz se realiza por terminal USB (stdio), botones y UART0 configurado (listo para depuraci\u00f3n/expansi\u00f3n).</p>"},{"location":"practicas/uart/Examen/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Servo List Runner (3 modos) </li> <li>Autor: Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 22/10/2025 </li> <li>Descripci\u00f3n breve: Control de servo por PWM a ~50 Hz; comandos por consola para llenar una lista de \u00e1ngulos y dos botones para navegar entre elementos.</li> </ul> <p>Informaci\u00f3n del proyecto</p> <ul> <li>Lenguaje: C++ (Pico SDK, usa <code>std::string</code>)</li> <li>MCU: Raspberry Pi Pico / Pico 2 (RP2040)</li> <li>Librer\u00edas: <code>pico/stdlib.h</code>, <code>hardware/pwm.h</code>, <code>hardware/uart.h</code>, <code>&lt;string&gt;</code>, <code>stdio</code></li> <li>Estrategia general:</li> <li>Modo 0 (Escritura): desde la consola, comando <code>Escribir,</code> seguido de \u00e1ngulos separados por comas y terminados con <code>;</code> o <code>Enter</code>.  </li> <li>Modo 1 (Lectura): recorre y mueve el servo por todos los \u00e1ngulos almacenados, con pausa visible.  </li> <li>Modo 2 (Navegaci\u00f3n): mueve el servo manualmente por la lista con btn_next / btn_prev.  </li> <li>btn_mode: interrupci\u00f3n para alternar de 0 \u2192 1 \u2192 2 \u2192 0 (con mensaje por <code>printf</code>).</li> </ul>"},{"location":"practicas/uart/Examen/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico / Pico 2  </li> <li>1 servomotor (est\u00e1ndar) conectado a GPIO 15 (se\u00f1al), Vcc 5 V (o 3.3 V seg\u00fan servo) y GND com\u00fan  </li> <li>3 botones (NO) con pull-up interno:  </li> <li><code>btn_mode</code> \u2192 GPIO 16 (cambio de modo)  </li> <li><code>btn_next</code> \u2192 GPIO 17 (siguiente)  </li> <li><code>btn_prev</code> \u2192 GPIO 18 (anterior)  </li> <li>Fuente y cableado adecuados  </li> <li>PC con Pico SDK (compilaci\u00f3n CMake)</li> </ul>"},{"location":"practicas/uart/Examen/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM en el RP2040 para generar pulsos de 1\u20132 ms dentro de un periodo de 20 ms (~50 Hz) para servos.  </li> <li>Implementar una lista de \u00e1ngulos con validaci\u00f3n (0\u2013180).  </li> <li>Dise\u00f1ar tres modos de operaci\u00f3n con cambio por interrupci\u00f3n GPIO.  </li> <li>Practicar parsing de comandos v\u00eda consola y navegaci\u00f3n por botones con detecci\u00f3n de flanco.</li> </ul>"},{"location":"practicas/uart/Examen/#3-circuito","title":"3) Circuito","text":"<ul> <li>Servo: se\u00f1al en GPIO 15, GND com\u00fan con el Pico, alimentaci\u00f3n del servo acorde a su especificaci\u00f3n (idealmente fuente separada con tierras comunes).  </li> <li>Botones: <code>btn_mode=GP16</code>, <code>btn_next=GP17</code>, <code>btn_prev=GP18</code> \u2192 configurar como entrada con <code>gpio_pull_up()</code>. El otro terminal de cada bot\u00f3n a GND.  </li> <li>UART0 (para depuraci\u00f3n/expansi\u00f3n): <code>TX=GP0</code>, <code>RX=GP1</code> (cruzado si conectas a otro dispositivo).</li> </ul> <p>Con pull-up, el bot\u00f3n en reposo lee 1 y al presionar baja a 0. En este proyecto, <code>btn_mode</code> usa IRQ por flanco de bajada.</p>"},{"location":"practicas/uart/Examen/#4-codigo-referencia","title":"4) C\u00f3digo (referencia)","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include \"hardware/pwm.h\"\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define btn_mode 16\n#define btn_next 17\n#define btn_prev 18\n#define PWM_PIN 0\n#define SERVO_PIN 15\nusing namespace std;\n#define list 10\n\nvolatile int programa = 0;\n\nuint16_t angle_to_pwm(float angle) {\n    float pulse_ms = 1.0f + (angle / 180.0f);   // 1.0 \u2192 2.0 ms\n    float duty = (pulse_ms / 20.0f) * 39062.0f; // 20 ms periodo total\n    return (uint16_t)duty;\n}\n\n// --- Rutina de interrupci\u00f3n ---\nstatic void button_isr(uint gpio, uint32_t events) {\n    if (gpio == btn_mode &amp;&amp; (events &amp; GPIO_IRQ_EDGE_FALL)) { // flanco de bajada (presionado)\n        programa++;\n        if (programa &gt; 2) { programa = 0; }\n        if (programa == 0)      printf(\"Modo de Escritura Activado\\n\");\n        else if (programa == 1) printf(\"Modo de Lectura Activado\\n\");\n        else if (programa == 2) printf(\"Modo de Navegaci\u00f3n Activado\\n\");\n        sleep_ms(500); // (anti-rebote b\u00e1sico, ojo: dentro de ISR)\n    }\n}\n\nint main() {\n    int pos = 0;\n    stdio_init_all();\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(SERVO_PIN);\n    pwm_set_clkdiv(slice, 64.0f);\n    pwm_set_wrap(slice, 39062);\n    pwm_set_enabled(slice, true);\n\n    int next1 = 0;\n    int prev1 = 0;\n\n    // --- Configuraci\u00f3n de botones ---\n    gpio_init(btn_mode); gpio_set_dir(btn_mode, GPIO_IN); gpio_pull_up(btn_mode);\n    gpio_init(btn_next); gpio_set_dir(btn_next, GPIO_IN); gpio_pull_up(btn_next);\n    gpio_init(btn_prev); gpio_set_dir(btn_prev, GPIO_IN); gpio_pull_up(btn_prev);\n\n    // --- Interrupci\u00f3n ---\n    gpio_set_irq_enabled_with_callback(btn_mode, GPIO_IRQ_EDGE_FALL, true, &amp;button_isr);\n\n    string p1 = \"\";\n    int lista[list] = {720,720,720,720,720,720,720,720,720,720}; // 720 = vac\u00edo\n    int i = -1;\n\n    while (true) {\n        int pos = 0;\n\n        if (programa == 0) { // --- Escritura ---\n            int ch = getchar_timeout_us(0);\n            if (ch != PICO_ERROR_TIMEOUT) {\n                if (ch == ',') {\n                    if (p1 == \"Escribir\" || p1 == \"write\" || p1 == \"WRITE\" ||\n                        p1 == \"escribir\" || p1 == \"Write\" || p1 == \"ESCRIBIR\") {\n                        p1 = \"\";\n                        int contador = 0;\n                        for(int k=0;k&lt;list;k++) if (lista[k]!=720) contador++;\n                        if (contador == list) {\n                            printf(\"Lista llena, no se pueden agregar m\u00e1s elementos.\\n\");\n                            p1 = \"\";\n                            continue;\n                        } else {\n                            i++;\n                            while (ch != ';' &amp;&amp; ch != '\\n') {\n                                ch = getchar_timeout_us(0);\n                                if (ch != PICO_ERROR_TIMEOUT) {\n                                    if (ch == ',') {\n                                        printf(\"Eco: %s\\n\", p1.c_str());\n                                        if(stoi(p1)&gt;180 || stoi(p1)&lt;0){\n                                            printf(\"Valor fuera de rango (0-180).\\n\");\n                                            i--;\n                                        } else {\n                                            lista[i] = stoi(p1);\n                                            i++;\n                                            p1 = \"\";\n                                        }\n                                    } else if (ch == ';' || ch == '\\n') {\n                                        if(stoi(p1)&gt;180 || stoi(p1)&lt;0){\n                                            printf(\"Valor fuera de rango (0-180).\\n\");\n                                            i--;\n                                        } else {\n                                            lista[i] = stoi(p1);\n                                            p1 = \"\";\n                                        }\n                                    } else {\n                                        p1 += (char)ch;\n                                    }\n                                    // imprimir lista actual\n                                    printf(\"Lista: \");\n                                    for (int k=0;k&lt;=i;++k){ printf(\"%d%s\", lista[k], (k+1&lt;=i)?\", \":\"\"); }\n                                    printf(\"\\n\");\n                                }\n                            }\n                        }\n                    } else if (p1 == \"Remplazar\" || p1 == \"replace\" || p1 == \"REPLACE\" ||\n                            p1 == \"remplazar\" || p1 == \"REMPLAZAR\") {\n                        p1 = \"\"; // (reservado para extensi\u00f3n)\n                    }\n                }\n\n                if (ch == ';' || ch == '\\n') {\n                    if (p1 == \"Borrar\" || p1 == \"delete\" || p1 == \"DELETE\" ||\n                        p1 == \"borrar\" || p1 == \"BORRAR\") {\n                        for (int k=0;k&lt;list;k++) lista[k]=720;\n                        i = -1;\n                        printf(\"Ok, Lista borrada\\n\");\n                    }\n                    p1 = \"\";\n                } else {\n                    p1 += (char)ch;\n                }\n            }\n        } \n        else if (programa == 1) { // --- Lectura secuencial ---\n            while(programa == 1){\n                int contador = 0;\n                for(int k=0;k&lt;list;k++) if (lista[k]!=720) contador++;\n                if (contador == 0) {\n                    printf(\"La lista est\u00e1 vac\u00eda. Cambie al modo de escritura para agregar elementos.\\n\");\n                    sleep_ms(1500);\n                } else {\n                    int j = 0;\n                    while(programa == 1 &amp;&amp; j &lt; contador){\n                        printf(\"posici\u00f3n: %d , valor: %d\\n\", j, lista[j]);\n                        pwm_set_gpio_level(SERVO_PIN, angle_to_pwm(lista[j]));\n                        printf(\"\u00c1ngulo: %.1f\u00b0\\n\", lista[j]);\n                        sleep_ms(1500);\n                        j++;\n                    }\n                }\n            }          \n        } \n        else if (programa == 2) { // --- Navegaci\u00f3n manual ---\n            while (programa == 2) {\n                if (lista[pos] == 720) pos--;\n                int contador = 0;\n                for(int k=0;k&lt;list;k++) if (lista[k]!=720) contador++;\n\n                // bot\u00f3n siguiente (detecci\u00f3n de flanco)\n                if (next1 == 0 &amp;&amp; gpio_get(btn_next) == 1){\n                    if (contador == 0) {\n                        printf(\"Lista Vacia, no se puede avanzar.\\n\");\n                        sleep_ms(100);\n                    } else {\n                        pos++;\n                        printf(\"siguiente \\n\");\n                        if (lista[pos] == 720) { printf(\"Valor no v\u00e1lido, regresando a %d\\n\", pos-1); pos--; }\n                        if (pos == list) pos = 0;\n                        printf(\"posici\u00f3n: %d , valor: %d\\n\", pos, lista[pos]);\n                        pwm_set_gpio_level(SERVO_PIN, angle_to_pwm(lista[pos]));\n                        printf(\"\u00c1ngulo: %.1f\u00b0\\n\", lista[pos]);\n                        sleep_ms(200);\n                    }\n                } \n                next1 = gpio_get(btn_next);\n\n                // bot\u00f3n anterior (detecci\u00f3n de flanco)\n                if (prev1 == 0 &amp;&amp; gpio_get(btn_prev) == 1) {\n                    if (contador == 0) {\n                        printf(\"Lista Vacia, no se puede avanzar.\\n\");\n                        sleep_ms(100);\n                    } else {\n                        pos--;\n                        printf(\"anterior \\n\");\n                        if (pos == -1) { printf(\"Valor no v\u00e1lido, regresando a %d\\n\", pos+1); pos++; }\n                        if (pos == list) pos = 0;\n                        printf(\"posici\u00f3n: %d , valor: %d\\n\", pos, lista[pos]);\n                        pwm_set_gpio_level(SERVO_PIN, angle_to_pwm(lista[pos]));\n                        printf(\"\u00c1ngulo: %.1f\u00b0\\n\", lista[pos]);\n                        sleep_ms(200);\n                    }\n                }\n                prev1 = gpio_get(btn_prev);\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"practicas/uart/Examen/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/uart/Examen/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>Servo PWM: <code>SERVO_PIN = GP15</code> (funci\u00f3n PWM)</li> <li>Botones: <code>btn_mode = GP16</code>, <code>btn_next = GP17</code>, <code>btn_prev = GP18</code> con pull-up</li> <li>UART0: <code>TX = GP0</code>, <code>RX = GP1</code>, <code>BAUD_RATE = 115200</code>, formato 8N1</li> </ul>"},{"location":"practicas/uart/Examen/#b-pwm-para-servomotor","title":"b) PWM para servomotor","text":"<p>Se configura el slice correspondiente a GP15 con: - <code>clkdiv = 64.0f</code> - <code>wrap = 39062</code> \u2192 periodo \u2248 20 ms (50 Hz)</p> <p><code>angle_to_pwm(angle)</code> mapea 0\u2013180\u00b0 a 1.0\u20132.0 ms de pulso: - <code>pulse_ms = 1.0 + angle/180.0</code> - <code>duty = (pulse_ms / 20.0) * 39062</code></p>"},{"location":"practicas/uart/Examen/#c-estructuras-de-datos","title":"c) Estructuras de datos","text":"<ul> <li><code>lista[10]</code> almacena hasta 10 \u00e1ngulos (enteros).</li> <li>Marcador de vac\u00edo: <code>720</code>.</li> <li>\u00cdndice <code>i</code> lleva el \u00faltimo \u00edndice v\u00e1lido (inicia en <code>-1</code>).</li> </ul>"},{"location":"practicas/uart/Examen/#d-maquina-de-estados-modos","title":"d) M\u00e1quina de estados (modos)","text":"<p>Modo 0 \u2013 Escritura (<code>programa == 0</code>) - Comando de entrada: <code>Escribir,</code> (admite variantes de may\u00fasculas/min\u00fasculas). - Luego, n\u00fameros separados por comas y terminados con <code>;</code> o Enter. - Cada n\u00famero se valida (0\u2013180) antes de guardarse; si es inv\u00e1lido, se descarta y se ajusta <code>i</code>. - <code>Borrar;</code> limpia la lista (rellena con <code>720</code>).</p> <p>Modo 1 \u2013 Lectura - Recorre autom\u00e1ticamente los elementos v\u00e1lidos de <code>lista</code> y mueve el servo; pausa de 1.5 s entre pasos.</p> <p>Modo 2 \u2013 Navegaci\u00f3n - Avance/retroceso manual con <code>btn_next</code> y <code>btn_prev</code> usando detecci\u00f3n de flanco (variables <code>next1</code>/<code>prev1</code>). - Muestra posici\u00f3n y valor, aplica el \u00e1ngulo al servo y espera 200 ms.</p>"},{"location":"practicas/uart/Examen/#6-video-demostracion","title":"6) Video Demostracion:","text":""},{"location":"practicas/uart/uart/","title":"-Comunicaci\u00f3n UART","text":""},{"location":"practicas/uart/uart/#uart-eco-y-control-led-entre-dos-pico-raspberry-pi-pico-pico-2","title":"UART Eco y Control LED entre dos Pico (Raspberry Pi Pico / Pico 2)","text":"<p>Este proyecto implementa comunicaci\u00f3n serie UART entre una Raspberry Pi Pico y otro dispositivo (otro Pico, PC con adaptador USB\u2013TTL, etc.). El programa eco reconstruye texto recibido por USB (stdio) y lo reenv\u00eda por UART0 cuando detecta fin de l\u00ednea (enter o <code>.</code>). Adem\u00e1s, recibe comandos por UART para controlar un LED (<code>LEDON</code> / <code>LEDOFF</code>) y env\u00eda \u201cLEDON\u201d cuando detecta la pulsaci\u00f3n de un bot\u00f3n.</p>"},{"location":"practicas/uart/uart/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: UART Eco + LED Control </li> <li>Autor: Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 21/10/2025 </li> <li>Descripci\u00f3n breve: Comunicaci\u00f3n UART a 115200 baudios con eco, reconstrucci\u00f3n de mensajes y control de LED mediante comandos de texto.</li> </ul> <p>Informaci\u00f3n del proyecto</p> <ul> <li>Lenguaje: C++ (Pico SDK, usa <code>std::string</code>)  </li> <li>MCU: Raspberry Pi Pico / Pico 2 (RP2040)  </li> <li>Librer\u00edas: <code>pico/stdlib.h</code>, <code>hardware/uart.h</code>, <code>&lt;string&gt;</code>, <code>stdio</code> </li> <li>Estrategia: </li> <li>USB stdio \u2192 reconstruye <code>p</code> y env\u00eda por UART0 al recibir <code>.</code> o <code>\\n</code>.  </li> <li>UART0 RX \u2192 reconstruye <code>c</code> y, al cerrar l\u00ednea, interpreta: <code>LEDON</code> / <code>LEDOFF</code> / inv\u00e1lido.  </li> <li>Bot\u00f3n \u2192 al presionar, transmite <code>\"LEDON\\n\"</code> por UART0.</li> </ul>"},{"location":"practicas/uart/uart/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico / Pico 2  </li> <li>1 LED con resistencia 220\u2013330 \u03a9 en GPIO 16 </li> <li>1 bot\u00f3n (NO) en GPIO 17 con pull-up interno </li> <li>Cableado y protoboard  </li> <li>Si conectas dos Picos por UART: GP0\u2194GP1 cruzado (TX\u2192RX, RX\u2192TX) y GND com\u00fan</li> </ul>"},{"location":"practicas/uart/uart/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar UART0 en RP2040 (115200-8N1).  </li> <li>Distinguir flujos: USB stdio (teclado/terminal) vs UART hardware.  </li> <li>Reconstruir mensajes por caracteres y delimitar por <code>.</code> o <code>\\n</code>.  </li> <li>Implementar un mini-protocolo de texto (<code>LEDON</code>, <code>LEDOFF</code>).  </li> <li>Leer GPIO (bot\u00f3n con pull-up) y enviar comandos por UART en respuesta.  </li> </ul>"},{"location":"practicas/uart/uart/#3-circuito","title":"3) Circuito","text":"<ul> <li>UART0: </li> <li><code>TX_PIN</code> \u2192 GPIO 0 (TX0) </li> <li><code>RX_PIN</code> \u2192 GPIO 1 (RX0) </li> <li>Conecta TX de un dispositivo al RX del otro y GND com\u00fan.  </li> <li>LED de usuario: GPIO 16 (con resistencia en serie a GND si activas con nivel alto).  </li> <li>Bot\u00f3n: GPIO 17 con <code>gpio_pull_up()</code>; el otro terminal a GND.  </li> <li>Alimentaci\u00f3n: USB del Pico.</li> </ul>"},{"location":"practicas/uart/uart/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>```cpp\n#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define button_pin 17\n#define led_PIN 16\nusing namespace std; // USO DE STRING en la terminal\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART); // DEFINE TX Y RX\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    uart_init(UART_ID, BAUD_RATE); // VELOCIDAD DE TRANSMISI\u00d3N\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE); // 8N1\n\n    gpio_init(button_pin);\n    gpio_set_dir(button_pin, GPIO_IN);\n    gpio_pull_up(button_pin);\n    gpio_init(led_PIN);\n    gpio_set_dir(led_PIN, GPIO_OUT);\n\n    string c = \"\"; // RECONSTRUCCI\u00d3N de la palabra recibida por UART\n    string p = \"\"; // RECONSTRUCCI\u00d3N de la palabra recibida por USB stdio\n\n    // Estado previo del bot\u00f3n para detectar flanco\n    int prev = 1;\n\n    while (true){\n        // \u2014\u2014\u2014 Entrada por USB stdio \u2014\u2014\u2014\n        int ch = getchar_timeout_us(0); // LEE UN CAR\u00c1CTER (no bloqueante)\n        if (ch != PICO_ERROR_TIMEOUT) { \n            printf(\"Eco: %c\\n\", (char)ch); \n            p += (char)ch; // reconstruye palabra\n\n            // Al cerrar l\u00ednea, env\u00eda por UART\n            if (ch == '.' || ch == '\\n'){\n                uart_puts(UART_ID, p.c_str()); // env\u00eda a UART (otro Pico)\n                p.clear();\n            }\n        }\n\n        // \u2014\u2014\u2014 Bot\u00f3n: env\u00edo de comando por UART (detecci\u00f3n de flanco) \u2014\u2014\u2014\n        int now = gpio_get(button_pin);\n        if (prev == 1 &amp;&amp; now == 0) { // transici\u00f3n alto-&gt;bajo\n            printf(\"Button pressed!\\n\");\n            uart_puts(UART_ID, \"LEDON\\n\");\n            sleep_ms(200); // antirrebote b\u00e1sico\n        }\n        prev = now;\n\n        // \u2014\u2014\u2014 Entrada por UART hardware \u2014\u2014\u2014\n        if (uart_is_readable(UART_ID)) {\n            char character = uart_getc(UART_ID); // LEE UN CAR\u00c1CTER\n            printf(\"%c\\n\", character); // imprime recibido\n\n            if (character == '\\n' || character == '.'){\n                if (c == \"LEDON\"){\n                    gpio_put(led_PIN, 1);\n                    printf(\"LED is ON\\n\");\n                }\n                else if (c == \"LEDOFF\"){\n                    gpio_put(led_PIN, 0);\n                    printf(\"LED is OFF\\n\");\n                } \n                else{\n                    uart_puts(UART_ID, \"Invalid Command\\n\");\n                }\n                c.clear();\n            } else {\n                c += character;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"practicas/uart/uart/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/uart/uart/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>UART0: <code>TX_PIN=GP0</code>, <code>RX_PIN=GP1</code>, <code>BAUD_RATE=115200</code>, formato 8N1.</li> <li>LED: <code>led_PIN=GP16</code> como salida.</li> <li>Bot\u00f3n: <code>button_pin=GP17</code> con pull-up interno (reposo = 1, presionado = 0).</li> </ul>"},{"location":"practicas/uart/uart/#b-variables-clave","title":"b) Variables clave","text":"<ul> <li><code>std::string p</code>: reconstruye el mensaje proveniente de USB stdio (teclado/terminal).</li> <li><code>std::string c</code>: reconstruye el mensaje recibido por UART0.</li> <li><code>prev/now</code>: detecci\u00f3n de flanco de bot\u00f3n (alto \u2192 bajo).</li> </ul>"},{"location":"practicas/uart/uart/#c-flujo-por-usb-stdio-uart","title":"c) Flujo por USB stdio \u2192 UART","text":"<ol> <li>Se lee un car\u00e1cter con <code>getchar_timeout_us(0)</code> (no bloqueante).</li> <li>Se hace \u201ceco\u201d (<code>printf(\"Eco: %c\\n\", ...)</code>) y se concatena a <code>p</code>.</li> <li>Si el car\u00e1cter es <code>.</code> o <code>\\n</code>, se considera fin de mensaje y se env\u00eda <code>p</code> por UART0 con <code>uart_puts</code>. Luego <code>p</code> se limpia.</li> </ol>"},{"location":"practicas/uart/uart/#d-flujo-por-uart-acciones","title":"d) Flujo por UART \u2192 acciones","text":"<ol> <li><code>uart_is_readable()</code> indica si hay datos en UART0.</li> <li>Se lee un car\u00e1cter con <code>uart_getc()</code> y se concatena a <code>c</code>.</li> <li>Al recibir <code>.</code> o <code>\\n</code>, se interpreta <code>c</code>:</li> <li><code>LEDON</code> \u2192 enciende GP16.</li> <li><code>LEDOFF</code> \u2192 apaga GP16.</li> <li>Otro texto \u2192 responde <code>\"Invalid Command\\n\"</code> por UART.    Se limpia <code>c</code>.</li> </ol>"},{"location":"practicas/uart/uart/#e-boton","title":"e) Bot\u00f3n","text":"<ul> <li>Se detecta flanco alto \u2192 bajo (pull-up).</li> <li>Al presionar, se transmite por UART: <code>\"LEDON\\n\"</code>.</li> <li><code>sleep_ms(200)</code> a\u00f1ade antirrebote b\u00e1sico.</li> </ul>"},{"location":"practicas/uart/uart/#6-procedimiento-de-ejecucion","title":"6) Procedimiento de ejecuci\u00f3n","text":"<ol> <li>Compilar como C++ (usa <code>&lt;string&gt;</code>). Aseg\u00farate de que el archivo tenga extensi\u00f3n <code>.cpp</code> y que tu <code>CMakeLists.txt</code> agregue <code>pico_stdlib</code> y <code>hardware_uart</code>.</li> <li>Habilita USB stdio si usar\u00e1s la consola por USB.</li> <li>Flashea el binario en el Pico.</li> <li>Conecta UART si usar\u00e1s dos Picos: cruza TX\u2194RX y comparte GND.</li> <li>Abre un terminal USB (ej. <code>115200-8N1</code>) y escribe texto: al poner <code>.</code> o Enter, se enviar\u00e1 por UART.</li> <li>Env\u00eda por UART desde el otro dispositivo: escribe <code>LEDON\\n</code> o <code>LEDOFF\\n</code> para controlar el LED del Pico.</li> </ol>"},{"location":"practicas/uart/uart/#7-resultados-esperados","title":"7) Resultados esperados","text":"<ul> <li>Al teclear en el terminal USB, ver\u00e1s l\u00edneas tipo <code>Eco: X</code> y, al finalizar con <code>.</code> o Enter, el Pico enviar\u00e1 esa cadena por UART.</li> <li>Si por UART llega <code>LEDON</code> (terminado en <code>.</code> o <code>\\n</code>), se enciende el LED en GP16 y se imprime <code>LED is ON</code>.</li> <li>Si llega <code>LEDOFF</code>, se apaga y se imprime <code>LED is OFF</code>.</li> <li>Cualquier otro comando retorna por UART <code>\"Invalid Command\\n\"</code>.</li> </ul>"},{"location":"practicas/uart/uart/#8-problemas-comunes-y-mejoras-recomendadas","title":"8) Problemas comunes y mejoras recomendadas","text":"<ul> <li>Antirrebote y flanco: usar estado previo <code>prev</code> y no variables sin inicializar.</li> <li>Formateo de impresi\u00f3n: usar <code>printf(\"%c\\n\", character);</code> en lugar de sumar punteros.</li> <li>Consistencia con <code>UART_ID</code>: usar <code>UART_ID</code> en todas las llamadas.</li> <li>Terminadores: asegurarse de finalizar mensajes con <code>\\n</code> o <code>.</code> para disparar el parseo.</li> </ul>"},{"location":"practicas/uart/uart/#9-conclusiones","title":"9) Conclusiones","text":"<ul> <li>Se implement\u00f3 una comunicaci\u00f3n UART con separaci\u00f3n clara USB/UART.</li> <li>Un protocolo textual m\u00ednimo permite controlar hardware (LED).</li> <li>Con mejoras de flancos y antirrebote, el sistema queda robusto y extensible.</li> </ul>"},{"location":"practicas/uart/uart/#10-preguntas-de-control","title":"10) Preguntas de control","text":"<ol> <li>\u00bfPor qu\u00e9 es necesario terminar los mensajes con <code>\\n</code> o <code>.</code>?</li> <li>\u00bfQu\u00e9 diferencia hay entre USB stdio y UART hardware en el Pico?</li> <li>\u00bfC\u00f3mo se cruzan correctamente las l\u00edneas TX/RX entre dos dispositivos UART?</li> <li>\u00bfC\u00f3mo detectar correctamente el flanco de un bot\u00f3n con pull-up?</li> <li>\u00bfQu\u00e9 ocurrir\u00eda si no inicializas una variable antes de usarla en una condici\u00f3n?</li> </ol>"},{"location":"practicas/uart/uart/#11-video-de-demostracion","title":"11) Video de demostraci\u00f3n","text":""}]}