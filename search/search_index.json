{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Portafolio de Antonio Mart\u00ednez","text":"<p>Mart\u00ednez</p> <p>\u00a1Bienvenido!  Este portafolio recopila proyectos, notas de clase y tutoriales relacionados con microcontroladores, sistemas embebidos e inteligencia artificial.</p> <p>En el men\u00fa lateral encontrar\u00e1s: - Proyectos destacados   - Tutoriales pr\u00e1cticos paso a paso - Referencias y enlaces \u00fatiles</p>"},{"location":"#sobre-mi","title":"Sobre m\u00ed","text":"<p>Soy estudiante de Ingenier\u00eda Mecatr\u00f3nica interesado en: - Microcontroladores y sistemas embebidos - Inteligencia artificial aplicada (visi\u00f3n por computadora, ciberseguridad) - Desarrollo de software y hardware para IoT  </p> <p>Habilidades t\u00e9cnicas: - Programaci\u00f3n: C/C++, Python, JavaScript - Electr\u00f3nica: dise\u00f1o de circuitos, sensores, actuadores - Herramientas: Git, AWS, SolidWorks, Arduino IDE, CATIA V5R21  </p> <p>Objetivos profesionales: Seguir desarrollando proyectos que combinen IA y sistemas embebidos, y eventualmente escalar mi startup tecnol\u00f3gica.</p>"},{"location":"analisis_cafeteras/","title":"An\u00e1lisis sobre las cafeteras de c\u00e1psulas","text":""},{"location":"analisis_cafeteras/#cafe-en-capsulas","title":"Caf\u00e9 en C\u00e1psulas","text":"<p>En esta presentaci\u00f3n exploraremos la evoluci\u00f3n y el impacto de las cafeteras de c\u00e1psulas. Revisaremos su origen hist\u00f3rico, el modelo de negocio que las hizo exitosas y c\u00f3mo han transformado los h\u00e1bitos de consumo de caf\u00e9 en hogares y oficinas. Tambi\u00e9n analizaremos sus principales ventajas y desventajas, los avances tecnol\u00f3gicos m\u00e1s recientes, y su penetraci\u00f3n en el mercado global. Finalmente, cerraremos con una reflexi\u00f3n sobre los retos que enfrenta este sistema, especialmente en t\u00e9rminos de sostenibilidad y costos, para entender por qu\u00e9 se ha convertido en un fen\u00f3meno tan relevante en la cultura del caf\u00e9. Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"controladores/","title":"Comparativa de Microcontroladores","text":"Perif\u00e9ricos, Memoria, Ecosistema, Costos, Arquitectura y Velocidad de Trabajo"},{"location":"controladores/#informacion","title":"Informacion","text":"<ul> <li>Nombre del proyecto: Comparativa de Microcontroladores</li> <li>Equipo / Autor(es): Antonio Mart\u00ednez</li> <li>Curso / Asignatura: Sistemas Embebidos</li> <li>Fecha: 23/08/2025</li> <li>Descripci\u00f3n breve: An\u00e1lisis comparativo de microcontroladores de distintas marcas considerando perif\u00e9ricos, memoria, ecosistema, costos, arquitectura y velocidad de trabajo.</li> </ul>"},{"location":"controladores/#introducion","title":"Introducion","text":""},{"location":"controladores/#sobre-los-microcontroladores","title":"Sobre los microcontroladores:","text":"<p>En el desarrollo de sistemas embebidos y proyectos electr\u00f3nicos, la elecci\u00f3n del microcontrolador adecuado es un paso cr\u00edtico. Cada microcontrolador se diferencia en varios aspectos t\u00e9cnicos y pr\u00e1cticos que determinan su rendimiento, facilidad de uso y costo. A continuaci\u00f3n, se explican los criterios utilizados en la tabla comparativa:</p> <ul> <li> <p>Perif\u00e9ricos: Son los m\u00f3dulos de hardware integrados que permiten la interacci\u00f3n del microcontrolador con el entorno. Incluyen interfaces de comunicaci\u00f3n (UART, SPI, I\u00b2C, USB, CAN), convertidores anal\u00f3gico-digital (ADC), generadores de PWM, temporizadores y otros. Su disponibilidad define qu\u00e9 tan vers\u00e1til puede ser el dispositivo en una aplicaci\u00f3n espec\u00edfica.</p> </li> <li> <p>Memoria: Se refiere a la capacidad de almacenamiento integrada.  </p> </li> <li>Flash: Guarda el programa principal (firmware).  </li> <li>SRAM: Es la memoria de trabajo usada durante la ejecuci\u00f3n.  </li> <li> <p>EEPROM o Flash externa: Permite guardar datos de manera permanente, incluso sin energ\u00eda.  </p> </li> <li> <p>Ecosistema: Hace referencia al conjunto de herramientas de software y librer\u00edas disponibles para programar y depurar el microcontrolador. Un ecosistema robusto (IDE, SDK, soporte en la comunidad) facilita el desarrollo, reduce la curva de aprendizaje y mejora la productividad.</p> </li> <li> <p>Costos: Indican el precio aproximado por unidad en vol\u00famenes peque\u00f1os. El costo influye directamente en la viabilidad de un proyecto, sobre todo en aplicaciones de bajo presupuesto o producci\u00f3n masiva.</p> </li> <li> <p>Arquitectura: Describe el tipo de n\u00facleo del procesador, ya sea de 8, 16 o 32 bits, y la familia a la que pertenece (por ejemplo, AVR, Cortex-M, Xtensa). La arquitectura determina las capacidades de procesamiento, eficiencia energ\u00e9tica y compatibilidad con herramientas de desarrollo.</p> </li> <li> <p>Velocidad de trabajo: Corresponde a la frecuencia de reloj m\u00e1xima (MHz) a la que puede operar el microcontrolador. A mayor velocidad, m\u00e1s operaciones por segundo, aunque tambi\u00e9n puede aumentar el consumo de energ\u00eda.</p> </li> </ul> <p>Esta comparativa permite visualizar de manera clara las diferencias entre distintas marcas y familias de microcontroladores, ayudando a seleccionar el dispositivo m\u00e1s apropiado seg\u00fan las necesidades del proyecto.</p>"},{"location":"controladores/#tabla-comparativa","title":"tabla comparativa","text":""},{"location":"controladores/#comparativa-de-microcontroladores_1","title":"Comparativa de Microcontroladores","text":"MCU Perif. Memoria Ecosistema $USD Arq. Vel. ATmega328P ADC10, UART, I\u00b2C, SPI, Timers, PWM 32KB / 2KB / 1KB EEPROM Arduino, MPLAB ~2.7 AVR 8-bit 20 MHz STM32F103C8 ADC12, USART, I\u00b2C, SPI, USB, CAN 64KB / 20KB STM32CubeIDE ~6 Cortex-M3 72 MHz LPC1768 Eth, USB OTG, CAN, UART, I\u00b2C, SPI, I\u00b2S, ADC, DAC 512KB / 64KB MCUXpresso ~14 Cortex-M3 100 MHz MSP430G2553 ADC10, UART, SPI, I\u00b2C, Timers 16KB / 512B CCS ~3.5 MSP430 16-bit 16 MHz ESP32-WROOM Wi-Fi, BT, ADC12, DAC, UART, SPI, I\u00b2C, PWM 520KB SRAM / 4MB flash ESP-IDF, Arduino ~3\u20137 Xtensa LX6 240 MHz RP2040 USB, UART, SPI, I\u00b2C, PWM, ADC, PIO 264KB SRAM / 2MB flash C/C++ SDK, MicroPython ~4 Cortex-M0+ 133 MHz"},{"location":"controladores/#resumen","title":"Resumen","text":"<p>La revisi\u00f3n comparativa de diferentes microcontroladores muestra que no existe un \u201cmejor\u201d dispositivo de manera absoluta, sino que cada uno responde a necesidades espec\u00edficas de dise\u00f1o.  </p> <ul> <li>Los ATmega328P y MSP430 destacan por su simplicidad, bajo consumo y facilidad de aprendizaje, ideales para proyectos educativos o aplicaciones sencillas.  </li> <li>Los STM32F103 y LPC1768 ofrecen mayor potencia de procesamiento y una amplia variedad de perif\u00e9ricos, adecuados para aplicaciones industriales o que requieren comunicaciones avanzadas.  </li> <li>El ESP32 resalta por integrar conectividad inal\u00e1mbrica (Wi-Fi y Bluetooth) a bajo costo, siendo muy utilizado en proyectos de IoT.  </li> <li>El RP2040 de Raspberry Pi se ha consolidado como una alternativa flexible y econ\u00f3mica, con un ecosistema creciente que lo hace atractivo para prototipado y desarrollo educativo.  </li> </ul> <p>En conclusi\u00f3n, la selecci\u00f3n del microcontrolador debe basarse en un balance entre costo, recursos disponibles, complejidad del proyecto y facilidad de desarrollo. Conocer las diferencias en perif\u00e9ricos, memoria, ecosistema, arquitectura y velocidad de trabajo permite tomar decisiones informadas que optimicen tanto el desempe\u00f1o como la viabilidad econ\u00f3mica de un proyecto embebido.</p>"},{"location":"controladores/#referencias","title":"Referencias","text":"<ul> <li>Microchip Technology Inc. (2025). ATmega328P Datasheet. Disponible en: https://www.microchip.com/en-us/product/ATmega328P </li> <li>STMicroelectronics (2025). STM32F103x8 Datasheet. Disponible en: https://www.st.com/en/microcontrollers-microprocessors/stm32f103.html </li> <li>NXP Semiconductors (2025). LPC1768 Product Data Sheet. Disponible en: https://www.nxp.com/part/LPC1768FBD100 </li> <li>Texas Instruments (2025). MSP430G2553 Datasheet. Disponible en: https://www.ti.com/product/MSP430G2553 </li> <li>Espressif Systems (2025). ESP32-WROOM-32 Datasheet. Disponible en: https://www.espressif.com/en/products/modules/esp32 </li> <li>Raspberry Pi Ltd. (2025). RP2040 Datasheet. Disponible en: https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html </li> </ul>"},{"location":"ejemplo/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"gitcmds/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"gitcmds/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"gitcmds/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"gitcmds/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"gitcmds/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"gitcmds/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"gitcmds/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"gitcmds/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"rana/","title":"Proyecto rana","text":""},{"location":"rana/#rana","title":"RANA","text":"<p>La contaminaci\u00f3n de lagos, estanques y peque\u00f1os cuerpos de agua es un problema creciente que afecta tanto al medio ambiente como a las comunidades locales. La acumulaci\u00f3n de basura pl\u00e1stica, hojas y residuos org\u00e1nicos provoca da\u00f1os en la biodiversidad, genera malos olores y dificulta el acceso al agua para fines recreativos o agr\u00edcolas.  </p> <p>La limpieza manual de estos espacios resulta complicada y poco eficiente, por lo que surge la necesidad de soluciones accesibles, aut\u00f3nomas y adaptadas a estos entornos. Este proyecto propone el dise\u00f1o de un robot acu\u00e1tico de navegaci\u00f3n asistida, capaz de recolectar residuos flotantes de forma econ\u00f3mica, sustentable y escalable:contentReference[oaicite:0]{index=0}.  </p> <p>Descargar especificaci\u00f3n (PDF)</p> <p>RANA </p>"},{"location":"rana/#analisis-sobre-la-problematica","title":"Analis\u00eds sobre la problematica:","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"rana/#diagrama-de-gantt-de-las-actividades-que-se-realizaran","title":"Diagrama de Gantt de las actividades que se realizaran:","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"rana/#rana-robot-acuatico-de-navegacion-asistida","title":"RANA \u2014 Robot Acu\u00e1tico de Navegaci\u00f3n Asistida","text":"<p>Aplicaci\u00f3n de la diapositiva \u201cCreando Valor\u201d al proyecto RANA</p> Categor\u00eda Descripci\u00f3n Socios Clave - Compa\u00f1eros y profesores que nos ayuden a mejorar el dise\u00f1o.   - Laboratorios de la universidad donde podamos probar el robot.   - Proveedores de piezas b\u00e1sicas (motores, sensores, paneles solares peque\u00f1os).   - Comunidades que nos permitan probar el robot en estanques peque\u00f1os. Actividades Clave - Dise\u00f1ar y armar el prototipo.   - Probarlo en agua para evaluar limpieza.   - Instalar sensores b\u00e1sicos.   - Dar mantenimiento y ajustar dise\u00f1o.   - Difundir el proyecto en redes o carteles. Propuesta de Valor - Robot econ\u00f3mico y f\u00e1cil de usar.   - Funciona aut\u00f3nomo o con control remoto.   - Mide par\u00e1metros b\u00e1sicos del agua.   - Limpia peque\u00f1as \u00e1reas y genera conciencia ambiental. Relaci\u00f3n con Clientes - Ense\u00f1ar a usar el robot.   - Pedir retroalimentaci\u00f3n.   - Colaborar con grupos ambientales. Segmentos de Clientes - Universidades o laboratorios.   - Comunidades con estanques.   - Grupos estudiantiles ambientales. Recursos Clave - Arduino, sensores, motores, bater\u00edas.   - Taller o laboratorio.   - T\u00fa y tus compa\u00f1eros.   - Materiales reciclables o econ\u00f3micos. Canales - Presentaciones en la universidad.   - Redes sociales.   - Ferias estudiantiles de innovaci\u00f3n. Estructura de Costos - Compra de componentes b\u00e1sicos.   - Ensamblaje y pruebas.   - Materiales de difusi\u00f3n. Fuentes de Ingreso - Apoyo de la universidad o becas.   - Premios en concursos estudiantiles.   - Posible venta a laboratorios o grupos estudiantiles."},{"location":"rana/#1-la-oferta-que-quiere-la-gente","title":"1) La oferta: \u00bfqu\u00e9 quiere la gente?","text":""},{"location":"rana/#rango-de-productos-oferta","title":"Rango de productos (oferta)","text":"<ul> <li>RANA Go (MVP) \u2014 Robot de limpieza con navegaci\u00f3n asistida (teleoperado con ayudas de rumbo y anticolisi\u00f3n), skimmer para s\u00f3lidos flotantes, filtro fino y telemetr\u00eda b\u00e1sica (turbidez, temperatura).</li> <li> <p>RANA Pro \u2014 Semi-aut\u00f3nomo con rutas guiadas, geocercas, detecci\u00f3n de obst\u00e1culos (LiDAR/c\u00e1mara/US), mapas de calor de basura y reportes autom\u00e1ticos para cumplimiento (antes/despu\u00e9s, kg recogidos, horas de operaci\u00f3n).</p> </li> <li> <p>Servicios complementarios: estudio inicial (l\u00ednea base de contaminaci\u00f3n), mantenimiento preventivo, retiro y disposici\u00f3n certificada, suscripci\u00f3n de monitoreo ambiental (turbidez, pH, DO, clorofila, cianobacterias opcional).</p> </li> </ul>"},{"location":"rana/#segmentos-objetivo-targeted","title":"Segmentos objetivo (targeted)","text":"<ol> <li>Municipios y organismos de agua (lagos urbanos, canales).</li> <li>Administradores de parques y clubs n\u00e1uticos (imagen p\u00fablica, seguridad sanitaria).</li> <li>Hoteles y marinas privadas (experiencia del visitante).</li> <li>Universidades/labs ambientales (datos y campo).</li> </ol>"},{"location":"rana/#2-propuesta-de-valor-insightful-unique-targeted","title":"2) Propuesta de valor (INSIGHTFUL \u2022 UNIQUE \u2022 TARGETED)","text":"<p>Dolores reales: limpieza manual costosa e intermitente; quejas vecinales por mal olor/algas; falta de datos verificables para justificar presupuesto. Ganancias: limpieza m\u00e1s frecuente y segura, evidencia cuantificada para reportes y decisiones, operaci\u00f3n silenciosa y con bajo OPEX.</p> <p>\u00daNICA (Unique) - Navegaci\u00f3n asistida: combina control humano con ayudas inteligentes (mantener rumbo, evitar colisiones, \u201climpia-en-ruta\u201d optimizada). - Data-first: reportes con kg/hora, m\u00b2 cubiertos, turbidez y mapas de calor \u2192 justifica inversi\u00f3n y muestra impacto. - Modular: skimmer, microalga boom, micro-dragado ligero, sensor pack opcional.</p> <p>DIRIGIDA (Targeted) - \u201cPeque\u00f1os-medianos cuerpos de agua urbanos (1\u201350 ha) con basura flotante recurrente y presi\u00f3n social por imagen/olores\u201d, responsable: Direcci\u00f3n de Parques/Servicios P\u00fablicos.</p>"},{"location":"rana/#creando-valor-rana-robot-acuatico-de-navegacion-asistida","title":"Creando Valor \u2014 RANA (Robot Acu\u00e1tico de Navegaci\u00f3n Asistida)","text":"INSIGHTFUL (Necesidades reales) UNIQUE (Dif\u00edcil de replicar) TARGETED (Cliente apasionado) Limpieza frecuente y segura de lagos/canales urbanos. Navegaci\u00f3n asistida: rumbo estable, retorno seguro y anticolisi\u00f3n. Municipios/organismos de agua con presi\u00f3n por quejas vecinales. indicadores cuantificables para justificar presupuesto (kg de residuos, m\u00b2 cubiertos, turbidez reducida). Operaci\u00f3n data-first con reportes autom\u00e1ticos y mapas de calor de basura. Direcciones de Parques/Servicios P\u00fablicos responsables de imagen y sanidad. Respuesta r\u00e1pida post-lluvias y en temporadas altas de residuos. Arquitectura modular (skimmer, sensores, micro-dragado) seg\u00fan sitio. Marinas/hoteles que cuidan la experiencia visual del visitante. Servicio integral: recolecci\u00f3n + disposici\u00f3n y mantenimiento con OPEX bajo. Autodiagn\u00f3stico y mantenimiento predictivo (horas de motor, bater\u00edas) Universidades/labs ambientales que requieren campa\u00f1as de monitoreo con evidencia."},{"location":"rana/#value-proposition","title":"VALUE PROPOSITION","text":"<p>RANA mantiene limpios los cuerpos de agua con navegaci\u00f3n asistida y entrega evidencia medible (kg recolectados, m\u00b2 cubiertos, turbidez) para reducir quejas y justificar presupuesto con datos.</p>"},{"location":"rana/#costos-del-producto","title":"Costos del producto:","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"practicas/barrido/","title":"Barrido de LEDs","text":"<p>Esta pr\u00e1ctica consiste en implementar un barrido de LEDs en el Raspberry Pi Pico, donde cinco LEDs muestran un \u201c1\u201d que se desplaza de izquierda a derecha y de regreso (0\u21921\u21922\u21923\u21924\u21923\u21922\u21921\u2026), reforzando el uso de operaciones l\u00f3gicas y control de salidas digitales.  </p>"},{"location":"practicas/barrido/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Barrido de LEDs </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: Se program\u00f3 un barrido de LEDs controlados por el Raspberry Pi Pico. </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>C: Se utiliza el lenguaje C con el SDK de Raspberry Pi Pico, aprovechando librer\u00edas como pico/stdlib.h para el manejo de GPIO y retardos de tiempo. - Raspberry Pi Pico / Pico 2  </p>"},{"location":"practicas/barrido/#material-utilizado","title":"Material utilizado:","text":"<ul> <li>Cable micro-USB / USB-C para la programaci\u00f3n y alimentaci\u00f3n  </li> <li>Protoboard  </li> <li>5 LEDs de 5 mm o SMD  </li> <li>5 resistencias (220 \u03a9 \u2013 330 \u03a9) para limitar la corriente de los LEDs  </li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>Computadora con Visual Studio Code y el entorno Pico SDK configurado  </li> <li>Alimentaci\u00f3n (a trav\u00e9s del puerto USB del Pico)  </li> </ul>"},{"location":"practicas/barrido/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>Comprender el uso de salidas digitales en el microcontrolador Configurar pines GPIO del Raspberry Pi Pico como salidas para controlar LEDs.  </p> </li> <li> <p>Implementar un patr\u00f3n din\u00e1mico de iluminaci\u00f3n Mostrar un barrido secuencial donde un LED encendido se desplaza a lo largo de cinco posiciones y regresa.  </p> </li> <li> <p>Aplicar l\u00f3gica de control secuencial Usar variables de posici\u00f3n y direcci\u00f3n para generar el movimiento del \u201c1\u201d en el arreglo de LEDs.  </p> </li> <li> <p>Familiarizarse con retardos en sistemas embebidos Implementar pausas controladas para observar el movimiento del LED encendido.  </p> </li> <li> <p>Relacionar teor\u00eda con pr\u00e1ctica Visualizar c\u00f3mo las operaciones l\u00f3gicas permiten implementar un control din\u00e1mico de hardware.  </p> </li> </ul>"},{"location":"practicas/barrido/#3-circuito","title":"3) Circuito","text":"<p>La siguiente imagen muestra las conexiones realizadas, se utilizaron 5 resistencias de 220 ohms y 5 LEDs rojos.  </p> <p> </p> <p> </p>"},{"location":"practicas/barrido/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n#include \"pico/stdlib.h\"\n\n#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define LED4 4\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4))\n\nint main() {\n    stdio_init_all();\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);\n\n    int pos = 0;\n    int dir = 1; // 1 = derecha, -1 = izquierda\n\n    while (true) {\n        uint32_t value = (1u &lt;&lt; pos);\n        gpio_put_masked(LED_MASK, value);\n        sleep_ms(200);\n\n        pos += dir;\n\n        if (pos == 4) dir = -1; // extremo derecho\n        if (pos == 0) dir = 1;  // extremo izquierdo\n    }\n    return 0;\n}\n</code></pre>"},{"location":"practicas/barrido/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":"<ul> <li> <p>Definiciones y m\u00e1scara <pre><code>#define LED0 0\n#define LED1 1\n#define LED2 2\n#define LED3 3\n#define LED4 4\n\n#define LED_MASK ((1u &lt;&lt; LED0) | (1u &lt;&lt; LED1) | (1u &lt;&lt; LED2) | (1u &lt;&lt; LED3) | (1u &lt;&lt; LED4))\n</code></pre> Se asignan los pines 0\u20134 para los LEDs. La m\u00e1scara permite inicializar y escribir en todos esos pines simult\u00e1neamente.</p> </li> <li> <p>Inicializaci\u00f3n <pre><code>gpio_init_mask(LED_MASK);\ngpio_set_dir_out_masked(LED_MASK);\n</code></pre> Los pines definidos se configuran como salida.</p> </li> <li> <p>Bucle principal <pre><code>uint32_t value = (1u &lt;&lt; pos);\ngpio_put_masked(LED_MASK, value);\n</code></pre> Solo el LED en la posici\u00f3n actual se enciende.</p> </li> </ul> <p>La variable dir controla la direcci\u00f3n del movimiento. Cuando llega al extremo derecho (LED4) cambia a izquierda, y al llegar al extremo izquierdo (LED0) cambia a derecha, logrando el efecto de ida y vuelta.</p>"},{"location":"practicas/inputs/","title":"Compuertas L\u00f3gicas con Botones y LED (Raspberry Pi Pico / Pico 2)","text":"<p>Implementaci\u00f3n de compuertas l\u00f3gicas (AND, OR, NOT, XOR, NAND, NOR) usando dos botones como entradas digitales y un LED como salida. Los botones usan pull-up interno (activos en bajo al presionar), y se incluye un debounce por software.</p>"},{"location":"practicas/inputs/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Compuertas L\u00f3gicas con GPIO </li> <li>Autor: Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 02/09/2025 </li> <li>Descripci\u00f3n breve: Se mapean dos entradas con botones a una salida LED que refleja la operaci\u00f3n l\u00f3gica seleccionada.</li> </ul> <p>Informaci\u00f3n del proyecto</p> <ul> <li>Lenguaje: C (Pico SDK)  </li> <li>MCU: Raspberry Pi Pico / Pico 2 (RP2040)  </li> <li>Librer\u00edas: <code>pico/stdlib.h</code>, <code>hardware/gpio.h</code> </li> <li>Entradas activas en: nivel bajo (por pull-up interno \u2192 al presionar = 0 l\u00f3gico)  </li> <li>Salida LED activa en: nivel alto</li> </ul>"},{"location":"practicas/inputs/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico / Pico 2  </li> <li>1 LED (salida) + 1 resistencia 220\u2013330 \u03a9  </li> <li>2 botones de pulso (entradas)  </li> <li>Cables, protoboard y cable USB  </li> <li>PC con VS Code + CMake + Pico SDK</li> </ul>"},{"location":"practicas/inputs/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar GPIO como entradas con <code>pull_up</code> y como salidas para LED.  </li> <li>Implementar compuertas l\u00f3gicas b\u00e1sicas con entradas discretas.  </li> <li>Manejar el rebote de botones por software de forma simple.  </li> <li>Proveer una base extensible para probar distintas compuertas.</li> </ul>"},{"location":"practicas/inputs/#3-circuito","title":"3) Circuito","text":"<ul> <li>Entradas (botones):</li> <li><code>BTN_A</code> \u2192 GPIO 14 \u2014 con <code>gpio_pull_up(BTN_A)</code> </li> <li><code>BTN_B</code> \u2192 GPIO 15 \u2014 con <code>gpio_pull_up(BTN_B)</code> </li> <li>El otro terminal de cada bot\u00f3n va a GND</li> <li>Salida (LED):</li> <li><code>LED_OUT</code> \u2192 GPIO 13  </li> <li>LED con resistencia en serie (220\u2013330 \u03a9), \u00e1nodo al GPIO y c\u00e1todo a GND (salida activa-alta)</li> <li>Tierra com\u00fan: compartir GND entre todos los elementos.  </li> </ul>"},{"location":"practicas/inputs/#4-codigo","title":"4) C\u00f3digo","text":"<p>Cambia <code>GATE_SELECTED</code> para elegir la compuerta a evaluar.</p> <p>```c</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/gpio.h\"\n\n// ========= Mapeo de pines =========\n#define BTN_A    14\n#define BTN_B    15\n#define LED_OUT  13\n\n// ========= Selecci\u00f3n de compuerta =========\n// Opciones: AND, OR, NOT_A, XOR, NAND, NOR\ntypedef enum { AND, OR, NOT_A, XOR, NAND, NOR } gate_t;\n#define GATE_SELECTED AND   // &lt;- Cambia aqu\u00ed la compuerta a evaluar\n\n// ========= Par\u00e1metros de debounce =========\n#define DEBOUNCE_MS 20\nstatic absolute_time_t next_read_time = {0};\n\n// Lee bot\u00f3n con pull-up y entrega 0/1 l\u00f3gico (1 = presionado)\nstatic inline bool read_button_active_low(uint pin) {\n    // Con pull-up: gpio_get(pin) == 1 (no presionado), 0 (presionado)\n    return gpio_get(pin) ? 0 : 1;\n}\n\nstatic inline bool debounce_ready(void) {\n    return absolute_time_diff_us(get_absolute_time(), next_read_time) &lt;= 0;\n}\n\nstatic inline void debounce_arm(void) {\n    next_read_time = make_timeout_time_ms(DEBOUNCE_MS);\n}\n\nstatic bool logic_eval(gate_t gate, bool a, bool b) {\n    switch (gate) {\n        case AND:   return (a &amp;&amp; b);\n        case OR:    return (a || b);\n        case NOT_A: return (!a);        // ignora B\n        case XOR:   return (a ^ b);\n        case NAND:  return !(a &amp;&amp; b);\n        case NOR:   return !(a || b);\n        default:    return false;\n    }\n}\n\nint main(void) {\n    stdio_init_all();\n\n    // Configuraci\u00f3n de pines\n    gpio_init(LED_OUT);\n    gpio_set_dir(LED_OUT, true);\n    gpio_put(LED_OUT, 0);\n\n    gpio_init(BTN_A);\n    gpio_set_dir(BTN_A, false);\n    gpio_pull_up(BTN_A);\n\n    gpio_init(BTN_B);\n    gpio_set_dir(BTN_B, false);\n    gpio_pull_up(BTN_B);\n\n    debounce_arm();\n\n    while (true) {\n        if (!debounce_ready()) {\n            sleep_ms(1);\n            continue;\n        }\n\n        // Lectura de entradas (1 = presionado, 0 = suelto)\n        bool A = read_button_active_low(BTN_A);\n        bool B = read_button_active_low(BTN_B);\n\n        // Evaluaci\u00f3n l\u00f3gica\n        bool Y = logic_eval(GATE_SELECTED, A, B);\n\n        // Actualizar salida\n        gpio_put(LED_OUT, Y ? 1 : 0);\n\n        // Rearmar debounce\n        debounce_arm();\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"practicas/inputs/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/inputs/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>Cancha / Entradas: <code>BTN_A</code> (GPIO 14), <code>BTN_B</code> (GPIO 15), ambos con pull-up interno (activos en bajo).  </li> <li>Salida / Puntuaci\u00f3n: <code>LED_OUT</code> (GPIO 13), activo en alto (enciende con <code>1</code>).  </li> </ul>"},{"location":"practicas/inputs/#b-variables-clave-estado-del-juego","title":"b) Variables clave (estado del juego)","text":"<ul> <li>Entradas A, B: se leen con la funci\u00f3n <code>read_button_active_low()</code>, que invierte la l\u00f3gica de <code>gpio_get()</code> para que 1 = presionado.  </li> <li>Compuerta seleccionada: <code>GATE_SELECTED</code> de tipo <code>gate_t</code> (AND / OR / NOT_A / XOR / NAND / NOR).  </li> <li>Debounce: <code>DEBOUNCE_MS</code> define la ventana m\u00ednima entre lecturas estables.  </li> </ul>"},{"location":"practicas/inputs/#c-inicializacion-de-gpio-y-botones","title":"c) Inicializaci\u00f3n de GPIO y botones","text":"<ul> <li>LED como salida y en bajo al inicio (<code>gpio_put(LED_OUT, 0)</code>).  </li> <li>Botones como entrada con <code>gpio_pull_up()</code>.  </li> <li>La inversi\u00f3n l\u00f3gica se concentra en <code>read_button_active_low()</code> para mantener el c\u00f3digo limpio.  </li> </ul>"},{"location":"practicas/inputs/#d-bucle-principal","title":"d) Bucle principal","text":"<ul> <li>Cada DEBOUNCE_MS (20 ms por defecto) se muestrean A y B.  </li> <li>Se eval\u00faa <code>logic_eval(GATE_SELECTED, A, B)</code>.  </li> <li>Se escribe la salida en <code>LED_OUT</code>.  </li> </ul>"},{"location":"practicas/inputs/#e-tablas-de-verdad-referencia","title":"e) Tablas de verdad (referencia)","text":"<p>Supuesto: 1 = bot\u00f3n presionado; 0 = suelto.  </p> A B AND OR XOR NAND NOR 0 0 0 0 0 1 1 0 1 0 1 1 1 0 1 0 0 1 1 1 0 1 1 1 1 0 0 0 <p>Para NOT_A (usa solo A):</p> A NOT_A 0 1 1 0"},{"location":"practicas/inputs/#6-consideraciones-de-hardware","title":"6) Consideraciones de hardware","text":"<ul> <li>Resistencia del LED: 220\u2013330 \u03a9 en serie.  </li> <li>Botones con pull-up: el otro terminal a GND.  </li> <li>Com\u00fan de GND: imprescindible para referencia de niveles.  </li> <li>Rebotes: el debounce por soft (20 ms) suele ser suficiente. Si observas parpadeos, sube a 30\u201340 ms o a\u00f1ade filtro RC.  </li> <li>Polaridad del LED: si est\u00e1 invertido (c\u00e1todo al GPIO), deber\u00e1s invertir la l\u00f3gica de <code>gpio_put()</code>.  </li> </ul>"},{"location":"practicas/inputs/#video-de-demostracion","title":"Video de demostraci\u00f3n","text":""},{"location":"practicas/pong/","title":"Juego tipo \u201cPong\u201d con LEDs e interrupciones (Raspberry Pi Pico)","text":"<p>Esta pr\u00e1ctica implementa un \u201cPong\u201d lineal con 5 LEDs. Una \u201cpelota\u201d recorre de izquierda a derecha y viceversa (posiciones 1\u21945). Cada jugador tiene un bot\u00f3n: si lo presiona cuando la pelota llega a su extremo, cambia la direcci\u00f3n y \u201cdevuelve\u201d el tiro. Si nadie responde y la pelota \u201csale\u201d por un extremo, se marca punto: se enciende un LED de \u201canotaci\u00f3n\u201d del lado ganador durante 2 s y el juego reinicia desde el centro.  </p>"},{"location":"practicas/pong/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Pong de LEDs con interrupciones </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/09/2025 </li> <li>Descripci\u00f3n breve: Juego de \u201cPong\u201d unidimensional usando 5 LEDs para la pelota, 2 salidas para puntos y 2 botones con interrupciones para devolver la pelota en los extremos. </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>). T\u00e9cnicas clave: manejo de GPIO, interrupciones por flanco de bajada, pull-ups internos, l\u00f3gica de estados. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"practicas/pong/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) + cable micro-USB/USB-C  </li> <li>Protoboard  </li> <li>7 LEDs (5 para \u201ccancha\u201d, 2 para puntos J1/J2)  </li> <li>7 resistencias 220\u2013330 \u03a9 (una por LED)  </li> <li>2 botones moment\u00e1neos</li> <li>2 resistencias 1K-2K \u03a9 para los botones</li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>PC con VS Code + Pico SDK configurado  </li> </ul>"},{"location":"practicas/pong/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Usar interrupciones GPIO para leer botones con pull-up interno (activo en bajo).  </li> <li>Modelar la l\u00f3gica de juego con variables de posici\u00f3n (<code>pos</code>) y direcci\u00f3n (<code>dir</code>).  </li> <li>Indicar estado del juego en hardware: 5 LEDs para pelota, 2 salidas para \u201cpunto\u201d.  </li> <li>Practicar estructura de programa embebido (inicializaci\u00f3n\u2013ISR\u2013bucle principal).  </li> </ul>"},{"location":"practicas/pong/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Botones (activos en bajo): - Un terminal del bot\u00f3n a GND; el otro a GPIO 14 (BTN_AVANZA) y GPIO 15 (BTN_RETRO). Se habilita <code>gpio_pull_up()</code>, por lo que al presionar el bot\u00f3n, la l\u00ednea cae a 0 (flanco de bajada).</p> <p>LEDs \u201ccancha\u201d (con resistencia a GND): - <code>LED4 \u2192 GPIO 9</code> - <code>LED0 \u2192 GPIO 10</code> - <code>LED1 \u2192 GPIO 11</code> - <code>LED2 \u2192 GPIO 12</code> - <code>LED3 \u2192 GPIO 13</code></p> <p>LEDs de \u201cpunto\u201d (o zumbadores, seg\u00fan el montaje): - <code>J1 \u2192 GPIO 7</code> (punto del jugador izquierdo) - <code>J2 \u2192 GPIO 8</code> (punto del jugador derecho)</p> <p>Recomendaci\u00f3n: conectar \u00e1nodo del LED a GPIO mediante resistencia serie y c\u00e1todo a GND. Con <code>gpio_put(pin, 1)</code> el LED enciende.</p> <p>Tabla r\u00e1pida de pines</p> Se\u00f1al GPIO Uso BTN_AVANZA 14 Bot\u00f3n jugador izquierdo BTN_RETRO 15 Bot\u00f3n jugador derecho LED4 9 Posici\u00f3n 1 (extremo izq) LED0 10 Posici\u00f3n 2 LED1 11 Posici\u00f3n 3 (centro) LED2 12 Posici\u00f3n 4 LED3 13 Posici\u00f3n 5 (extremo der) J1 7 Indicador de punto izq J2 8 Indicador de punto der <p>Diagrama de conexi\u00f3n </p>"},{"location":"practicas/pong/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include &lt;stdbool.h&gt;\n\n#define BTN_AVANZA 14\n#define BTN_RETRO  15\n\n#define LED4 9\n#define LED0 10\n#define LED1 11\n#define LED2 12\n#define LED3 13\n#define J1 7\n#define J2 8\n\nbool Ju1 = false;   // estado bot\u00f3n jugador 1\nbool Ju2 = false;   // estado bot\u00f3n jugador 2\nint pos = 1;        // posici\u00f3n inicial de la pelota\nint dir = 1;        // direcci\u00f3n inicial: 1=derecha, -1=izquierda\n\nstatic void accion(uint gpio, uint32_t events) {\n    // FIX: habilitaste FALL en main; aqu\u00ed tambi\u00e9n revisa FALL y atiende ambos botones\n    if (events &amp; GPIO_IRQ_EDGE_FALL) {\n        if (gpio == BTN_AVANZA) { if (pos == 1 /*&amp;&amp; Ju1*/) dir = 1; }  // Ju1 opcional\n        if (gpio == BTN_RETRO)  { if (pos == 5 /*&amp;&amp; Ju2*/) dir = -1; } // Ju2 opcional\n    }\n    gpio_acknowledge_irq(gpio, events);\n}\n\nint main() {\n    stdio_init_all();\n\n    const uint LEDS[5] = { LED4, LED0, LED1, LED2, LED3 };  // 9,10,11,12,13\n\n    for (int i = 0; i &lt; 5; i++) {                  // FIX: antes era &lt; 4\n        gpio_init(LEDS[i] );\n        gpio_set_dir(LEDS[i], true);\n        gpio_put(LEDS[i], 0);                      // FIX: apaga inicialmente\n    }\n\n    const uint PUNTOS[2] = { J1, J2 };\n    for (int i = 0; i &lt; 2; i++) {\n        gpio_init(PUNTOS[i] );                      // FIX: inicializa PUNTOS, no LEDS\n        gpio_set_dir(PUNTOS[i], true);              // FIX: salida\n        gpio_put(PUNTOS[i], 0);                     // FIX: apaga inicialmente\n    }\n\n    // Botones como entrada con pull-up (activo en bajo)\n    gpio_init(BTN_AVANZA); gpio_set_dir(BTN_AVANZA, false); gpio_pull_up(BTN_AVANZA);\n    gpio_init(BTN_RETRO);  gpio_set_dir(BTN_RETRO,  false); gpio_pull_up(BTN_RETRO);\n\n    // IRQ: instalas callback con el primero y habilitas tambi\u00e9n el segundo\n    gpio_set_irq_enabled_with_callback(BTN_AVANZA, GPIO_IRQ_EDGE_FALL, true, &amp;accion);\n    gpio_set_irq_enabled(BTN_RETRO,  GPIO_IRQ_EDGE_FALL, true);\n\n    while (true) {\n        // (Opcional) actualizar flags de botones si los quieres usar en otro lado\n        Ju1 = !gpio_get(BTN_AVANZA);\n        Ju2 = !gpio_get(BTN_RETRO);\n\n        // --- Movimiento autom\u00e1tico ---\n        pos += dir;\n\n        // Rebotes en bordes si nadie responde\n        if (pos == 6) {\n            for (int i = 0; i &lt; 5; i++) gpio_put(LEDS[i], 1);\n            gpio_put(J2, 1);\n            sleep_ms(2000);\n            gpio_put(J2, 0);\n            pos = 3;\n            // (tu l\u00f3gica original no reubica pos ni dir aqu\u00ed m\u00e1s all\u00e1 del if)\n        }\n\n        if (pos == 0) {\n            for (int i = 0; i &lt; 5; i++) gpio_put(LEDS[i], 1);\n            gpio_put(J1, 1);\n            sleep_ms(2000);\n            gpio_put(J1, 0);\n            pos = 3;\n        }\n\n        // --- Mostrar LEDs ---\n        for (int i = 0; i &lt; 5; i++) {\n            gpio_put(LEDS[i], (i + 1 == pos));     // LEDS[0] \u2194 pos=1 ... LEDS[4] \u2194 pos=5\n        }\n\n        sleep_ms(250);\n    }\n}\n</code></pre>"},{"location":"practicas/pong/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/pong/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>Botones: <code>BTN_AVANZA=14</code>, <code>BTN_RETRO=15</code> (entradas con pull-up, activos en bajo).</li> <li>LEDs \u201ccancha\u201d: <code>LED4=9</code>, <code>LED0=10</code>, <code>LED1=11</code>, <code>LED2=12</code>, <code>LED3=13</code>.   Se agrupan en <code>LEDS[5] = { LED4, LED0, LED1, LED2, LED3 }</code>, donde <code>pos=1</code> corresponde a <code>LEDS[0]</code> (GPIO 9) y <code>pos=5</code> a <code>LEDS[4]</code> (GPIO 13).</li> <li>Indicadores de punto: <code>J1=7</code> (izquierda), <code>J2=8</code> (derecha). Se configuran como salidas y se encienden 2 s al anotar.</li> </ul>"},{"location":"practicas/pong/#b-variables-de-estado","title":"b) Variables de estado","text":"<ul> <li><code>pos \u2208 {1,2,3,4,5}</code> indica la posici\u00f3n de la pelota.  </li> <li><code>dir \u2208 {+1, \u22121}</code> define la direcci\u00f3n (derecha/izquierda).  </li> <li><code>Ju1</code>, <code>Ju2</code> sirven como flags de lectura (opcionales, el juego funciona sin usarlas).</li> </ul>"},{"location":"practicas/pong/#c-interrupcion-accion","title":"c) Interrupci\u00f3n <code>accion()</code>","text":"<ul> <li>Se activa con flanco de bajada (<code>GPIO_IRQ_EDGE_FALL</code>) en cualquiera de los dos botones.</li> <li>L\u00f3gica de \u201cdevoluci\u00f3n\u201d:</li> <li>Si la pelota est\u00e1 en el extremo izquierdo (<code>pos==1</code>) y cae el bot\u00f3n izquierdo (<code>BTN_AVANZA</code>), se fuerza <code>dir = +1</code>.</li> <li>Si est\u00e1 en el extremo derecho (<code>pos==5</code>) y cae el bot\u00f3n derecho (<code>BTN_RETRO</code>), se fuerza <code>dir = \u22121</code>.</li> <li>Se llama a <code>gpio_acknowledge_irq()</code> para limpiar el evento atendido.</li> </ul>"},{"location":"practicas/pong/#d-inicializacion-en-main","title":"d) Inicializaci\u00f3n en <code>main()</code>","text":"<ul> <li><code>LEDS</code> y <code>PUNTOS</code> se inicializan como salidas y se apagan.  </li> <li>Botones se configuran como entradas con <code>gpio_pull_up()</code>.  </li> <li>Se registra la ISR con <code>gpio_set_irq_enabled_with_callback()</code> en <code>BTN_AVANZA</code> y se habilita tambi\u00e9n la IRQ de <code>BTN_RETRO</code>.</li> </ul>"},{"location":"practicas/pong/#e-bucle-principal","title":"e) Bucle principal","text":"<ul> <li>(Opcional) Actualiza <code>Ju1</code>/<code>Ju2</code> leyendo el estado instant\u00e1neo de los botones.  </li> <li>Movimiento: <code>pos += dir;</code> </li> <li>Punto/anotaci\u00f3n si la pelota \u201csale\u201d:</li> <li>Derecha: si <code>pos==6</code>, se encienden todos los LEDs de cancha, se activa <code>J2</code> por 2 s y se reinicia <code>pos=3</code>.</li> <li>Izquierda: si <code>pos==0</code>, se encienden todos los LEDs de cancha, se activa <code>J1</code> por 2 s y se reinicia <code>pos=3</code>. (La direcci\u00f3n <code>dir</code> no se reorienta expl\u00edcitamente tras el punto.)</li> <li>Render: se enciende \u00fanicamente el LED cuyo \u00edndice+1 == pos.</li> <li>Velocidad: <code>sleep_ms(250)</code> define la dificultad.</li> </ul>"},{"location":"practicas/pong/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Arranque: un \u00fanico LED encendido en la posici\u00f3n 1; la \u201cpelota\u201d avanza hacia la derecha (<code>dir=+1</code>).  </li> <li>Devoluci\u00f3n correcta: al llegar al LED extremo, si el jugador correspondiente presiona a tiempo, la pelota cambia de sentido sin salir.  </li> <li>Fallo: si nadie presiona y la pelota intenta pasar de <code>5\u21926</code> o <code>1\u21920</code>, se marca punto (<code>J2</code> o <code>J1</code>, respectivamente) y se reinicia en el centro (<code>pos=3</code>).  </li> </ul>"},{"location":"practicas/pong/#video-de-demostracion","title":"Video de demostraci\u00f3n","text":""},{"location":"practicas/secuencia/","title":"-Secuencia controlada","text":""},{"location":"practicas/secuencia/#direccion-de-secuenciaraspberry-pi-pico-pico-2","title":"Direcci\u00f3n de Secuencia(Raspberry Pi Pico / Pico 2)","text":"<p>Este proyecto implementa un controlador de la direcci\u00f3n de secuencia usando Raspberry Pi Pico. El sistema utiliza 5 LEDs para representar la cancha y 2 LEDs para la puntuaci\u00f3n. La \u201cpelota\u201d se mueve autom\u00e1ticamente en una direcci\u00f3n mediante un timer peri\u00f3dico; al llegar a un extremo, el controlador detiene la secuencia y espera la intervenci\u00f3n del jugador correspondiente a trav\u00e9s de interrupciones por bot\u00f3n. El controlador gestiona el cambio de direcci\u00f3n de la secuencia seg\u00fan la respuesta del jugador, reiniciando la pelota al centro si hay error y actualizando la puntuaci\u00f3n con los LEDs.</p>"},{"location":"practicas/secuencia/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Direcci\u00f3n de Secuencia </li> <li>Autor: Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 02/09/2025 </li> <li>Descripci\u00f3n breve: Direcci\u00f3n de Secuencia.</li> </ul> <p>Informaci\u00f3n del proyecto</p> <ul> <li>Lenguaje: C (Pico SDK)  </li> <li>MCU: Raspberry Pi Pico / Pico 2 (RP2040)  </li> <li>Librer\u00edas: <code>pico/stdlib.h</code>, <code>hardware/gpio.h</code>, <code>hardware/timer.h</code> </li> <li>Estrategia: Timer cada 500 ms mueve la pelota; en los extremos, se detiene y espera la IRQ del bot\u00f3n correcto.</li> </ul>"},{"location":"practicas/secuencia/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico / Pico 2  </li> <li>5 LEDs (cancha) + 2 LEDs (puntuaci\u00f3n)  </li> <li>7 resistencias 220\u2013330 \u03a9 (limitaci\u00f3n de corriente)  </li> <li>2 botones de pulso (Normally Open)  </li> <li>Cables, protoboard y cable USB  </li> <li>PC con VS Code + CMake + Pico SDK configurado</li> </ul>"},{"location":"practicas/secuencia/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Timers y concurrencia simple: Usar <code>repeating_timer</code> para l\u00f3gica peri\u00f3dica.  </li> <li>Interrupciones GPIO: Capturar eventos de bot\u00f3n sin bloquear el bucle principal.  </li> <li>M\u00e1quina de estados m\u00ednima: \u201cen marcha\u201d vs \u201cesperando respuesta en extremo\u201d.  </li> <li>Buenas pr\u00e1cticas de GPIO: Pull-ups, flancos adecuados y actualizaci\u00f3n clara de LEDs.  </li> <li>Retroalimentaci\u00f3n visual: Puntos con LEDs de score y reinicio al centro.</li> </ul>"},{"location":"practicas/secuencia/#3-circuito","title":"3) Circuito","text":"<ul> <li>Cancha (5 LEDs): GPIO 9\u201313 (cada uno con su resistencia a GND si el pin maneja nivel alto para encender).  </li> <li>Puntuaci\u00f3n: <code>LED_SCORE_P1</code> \u2192 GPIO 7, <code>LED_SCORE_P2</code> \u2192 GPIO 8.  </li> <li>Botones: <code>BTN_P1</code> \u2192 GPIO 14, <code>BTN_P2</code> \u2192 GPIO 15, ambos con pull-up interno; el otro terminal del bot\u00f3n a GND.  </li> <li>Alimentaci\u00f3n: v\u00eda USB del Pico.</li> </ul> <p>Con pull-up, el bot\u00f3n en reposo lee 1 y al presionar baja a 0. En este c\u00f3digo las IRQ est\u00e1n configuradas por flanco de subida (0x8u), es decir, al soltar.</p>"},{"location":"practicas/secuencia/#4-codigo","title":"4) C\u00f3digo","text":"<p>```c     #include      #include \"pico/stdlib.h\"     #include \"hardware/timer.h\"     #include \"hardware/gpio.h\" <pre><code>// Pines de LEDs de la cancha\n#define LED0 9\n#define LED1 10\n#define LED2 11\n#define LED3 12\n#define LED4 13\n\n// LEDs de puntuaci\u00f3n\n#define LED_SCORE_P1 7\n#define LED_SCORE_P2 8\n\n// Botones\n#define BTN_P1 14\n#define BTN_P2 15\n\n// Variables del juego\nvolatile int pelota_pos = 2;       // posici\u00f3n inicial (LED del centro)\nvolatile int direccion = 1;        // 1 \u2192 derecha, -1 \u2192 izquierda\nvolatile bool esperando_respuesta = false;\n\n// Prototipos\nbool mover_pelota(struct repeating_timer *t);\nvoid actualizar_leds();\nvoid btn_callback(uint gpio, uint32_t events);\n\nint main() {\n    stdio_init_all();\n\n    // Configuraci\u00f3n LEDs\n    int leds[] = {LED0, LED1, LED2, LED3, LED4, LED_SCORE_P1, LED_SCORE_P2};\n    for (int i = 0; i &lt; 7; i++) {\n        gpio_init(leds[i]);\n        gpio_set_dir(leds[i], true);\n        gpio_put(leds[i], 0);\n    }\n\n    // Configuraci\u00f3n botones\n    // Configuraci\u00f3n bot\u00f3n jugador 1\n    gpio_init(BTN_P1);\n    gpio_set_dir(BTN_P1, false);\n    gpio_pull_up(BTN_P1);\n\n    // Configuraci\u00f3n bot\u00f3n jugador 2\n    gpio_init(BTN_P2);\n    gpio_set_dir(BTN_P2, false);\n    gpio_pull_up(BTN_P2);\n\n    // Registrar el callback global UNA sola vez\n    gpio_set_irq_enabled_with_callback(BTN_P1, 0x8u, true, &amp;btn_callback);\n\n    // Habilitar interrupci\u00f3n tambi\u00e9n en el otro bot\u00f3n, sin registrar callback otra vez\n    gpio_set_irq_enabled(BTN_P2, 0x8u, true);\n\n    // Timer para mover la pelota\n    struct repeating_timer timer;\n    add_repeating_timer_ms(500, mover_pelota, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents(); // loop vac\u00edo, todo se maneja con interrupciones y timer\n    }\n}\n\n// Timer: mueve la pelota\nbool mover_pelota(struct repeating_timer *t) {\n    if (esperando_respuesta) return true; // espera al jugador\n\n    // Apagar LEDs\n    for (int i = LED0; i &lt;= LED4; i++) gpio_put(i, 0);\n\n    // Mover pelota\n    pelota_pos += direccion;\n\n    // Revisar si lleg\u00f3 al extremo\n    if (pelota_pos &lt;= 0) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 1\n        pelota_pos = 0;\n    } else if (pelota_pos &gt;= 4) {\n        esperando_respuesta = true; // espera bot\u00f3n del jugador 2\n        pelota_pos = 4;\n    }\n\n    actualizar_leds();\n    return true;\n}\n\n// Encender LED de la pelota\nvoid actualizar_leds() {\n    gpio_put(LED0, pelota_pos == 0);\n    gpio_put(LED1, pelota_pos == 1);\n    gpio_put(LED2, pelota_pos == 2);\n    gpio_put(LED3, pelota_pos == 3);\n    gpio_put(LED4, pelota_pos == 4);\n}\n\n// Callback de botones (interrupciones)\nvoid btn_callback(uint gpio, uint32_t events) {\n    if (!esperando_respuesta) return;\n\n    if (gpio == BTN_P1 &amp;&amp; pelota_pos == 0) {\n        direccion = 1; // devuelve hacia la derecha\n        esperando_respuesta = false;\n    } \n    else if (gpio == BTN_P2 &amp;&amp; pelota_pos == 4) {\n        direccion = -1; // devuelve hacia la izquierda\n        esperando_respuesta = false;\n    } \n    else {\n        // Fall\u00f3 \u2192 punto para el contrario\n        if (gpio == BTN_P1) {\n            gpio_put(LED_SCORE_P2, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P2, 0);\n        } else {\n            gpio_put(LED_SCORE_P1, 1);\n            sleep_ms(500);\n            gpio_put(LED_SCORE_P1, 0);\n        }\n        // Reiniciar pelota\n        pelota_pos = 2;\n        direccion = (gpio == BTN_P1) ? 1 : -1;\n        esperando_respuesta = false;\n    }\n    actualizar_leds();\n}\n</code></pre>"},{"location":"practicas/secuencia/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/secuencia/#a-definiciones-y-mapeo-de-pines","title":"a) Definiciones y mapeo de pines","text":"<ul> <li>Cancha (LEDs de juego): <code>LED0..LED4</code> en GPIO 9\u201313. Representan la posici\u00f3n de la pelota en la cancha.  </li> <li>Puntuaci\u00f3n: <code>LED_SCORE_P1</code> (GPIO 7) y <code>LED_SCORE_P2</code> (GPIO 8). Se encienden brevemente cuando el jugador contrario gana un punto.  </li> <li>Botones: <code>BTN_P1</code> (GPIO 14) y <code>BTN_P2</code> (GPIO 15), configurados con pull-up interno (en reposo = 1, presionado = 0).  </li> </ul>"},{"location":"practicas/secuencia/#b-variables-clave","title":"b) Variables clave","text":"<ul> <li><code>pelota_pos \u2208 {0..4}</code>: indica qu\u00e9 LED de la cancha est\u00e1 encendido, es decir, la posici\u00f3n actual de la pelota.  </li> <li><code>direccion \u2208 {+1, \u22121}</code>: determina si la pelota se mueve hacia la derecha (+1) o hacia la izquierda (\u22121).  </li> <li><code>esperando_respuesta (bool)</code>: cuando la pelota llega a un extremo, el avance se pausa hasta que el jugador correspondiente presione su bot\u00f3n.  </li> </ul>"},{"location":"practicas/secuencia/#c-inicializacion-de-gpio-y-botones","title":"c) Inicializaci\u00f3n de GPIO y botones","text":"<ul> <li>Los LEDs de la cancha y de puntuaci\u00f3n se configuran como salida y se inicializan en apagado (<code>gpio_put(...,0)</code>).  </li> <li>Los botones se configuran como entrada con <code>gpio_pull_up()</code>.  </li> <li>Se registra un callback global con <code>gpio_set_irq_enabled_with_callback()</code> para BTN_P1.  </li> <li>Se habilita tambi\u00e9n la interrupci\u00f3n de BTN_P2 con <code>gpio_set_irq_enabled()</code>, pero sin registrar otro callback (se reutiliza el mismo).  </li> <li>Las interrupciones se configuran en flanco de subida (0x8u), es decir, cuando el bot\u00f3n pasa de presionado a liberado.  </li> </ul>"},{"location":"practicas/secuencia/#d-temporizador-repetitivo-repeating_timer","title":"d) Temporizador repetitivo (<code>repeating_timer</code>)","text":"<ul> <li>Se crea un temporizador con <code>add_repeating_timer_ms(500, mover_pelota, ...)</code>, que ejecuta la funci\u00f3n <code>mover_pelota</code> cada 500 ms.  </li> <li>Si <code>esperando_respuesta = false</code>, la pelota avanza (<code>pelota_pos += direccion</code>).  </li> <li>Si llega a los extremos (<code>0</code> o <code>4</code>), se fija <code>esperando_respuesta = true</code> y el juego queda en pausa hasta que un jugador responda.  </li> </ul>"},{"location":"practicas/secuencia/#e-funcion-actualizar_leds","title":"e) Funci\u00f3n <code>actualizar_leds()</code>","text":"<ul> <li>Se encarga de reflejar la posici\u00f3n actual de la pelota encendiendo \u00fanicamente el LED correspondiente (<code>LED0..LED4</code>) y apagando los dem\u00e1s.  </li> </ul>"},{"location":"practicas/secuencia/#f-callback-de-botones-btn_callback","title":"f) Callback de botones (<code>btn_callback</code>)","text":"<ul> <li>Solo act\u00faa si <code>esperando_respuesta = true</code>.  </li> <li>Caso correcto: </li> <li>Si la pelota est\u00e1 en el extremo izquierdo (<code>pelota_pos==0</code>) y se presiona BTN_P1, se cambia la direcci\u00f3n a derecha (<code>direccion=+1</code>) y se reanuda el juego.  </li> <li>Si la pelota est\u00e1 en el extremo derecho (<code>pelota_pos==4</code>) y se presiona BTN_P2, se cambia la direcci\u00f3n a izquierda (<code>direccion=-1</code>) y se reanuda el juego.  </li> <li>Caso incorrecto (falla): </li> <li>Si se presiona el bot\u00f3n equivocado, se enciende el LED de puntuaci\u00f3n del contrario durante 500 ms.  </li> <li>Despu\u00e9s, la pelota se reinicia al centro (<code>pelota_pos=2</code>) y la direcci\u00f3n inicial se ajusta seg\u00fan qui\u00e9n fall\u00f3.  </li> </ul>"},{"location":"practicas/secuencia/#g-maquina-de-estados-implicita","title":"g) M\u00e1quina de estados impl\u00edcita","text":"<ol> <li>RUNNING: la pelota avanza autom\u00e1ticamente cada 500 ms.  </li> <li>WAIT_INPUT: al llegar a un extremo, se detiene y espera la respuesta del jugador.  </li> <li>SCORE: si el jugador falla, se muestra el punto en el LED correspondiente, se reinicia la pelota en el centro y se regresa a RUNNING.  </li> </ol>"},{"location":"practicas/secuencia/#video-de-demostracion","title":"Video de demostraci\u00f3n","text":""},{"location":"practicas/sumador/","title":"Contador Binario de 4 Bits","text":"<p>Esta pr\u00e1ctica consiste en implementar un contador binario de 4 bits utilizando el Raspberry Pi Pico, donde cuatro LEDs muestran en tiempo real la representaci\u00f3n binaria de los n\u00fameros del 0 al 15. El objetivo es aplicar el uso de operaciones l\u00f3gicas y m\u00e1scaras para el control de salidas digitales y reforzar la comprensi\u00f3n del sistema binario..  </p>"},{"location":"practicas/sumador/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Contador Binario de 4 bits </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 25/08/2025 </li> <li>Descripci\u00f3n breve: Se programo un contador binario de cuatro bits.</li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>C: Se utiliza el lenguaje C con el SDK de Raspberry Pi Pico, aprovechando librer\u00edas como pico/stdlib.h para el manejo de GPIO y retardos de tiempo. - Raspberry Pi Pico / Pico 2  </p>"},{"location":"practicas/sumador/#material-utilizado","title":"Material utilizado:","text":"<ul> <li>Cable micro-USB / USB-C para la programaci\u00f3n y alimentaci\u00f3n  </li> <li>Protoboard  </li> <li>4 LEDs de 5 mm o SMD  </li> <li>4 resistencias (220 \u03a9 \u2013 330 \u03a9) para limitar la corriente de los LEDs  </li> <li>Cables de conexi\u00f3n (jumpers)  </li> <li>Computadora con Visual Studio Code y el entorno Pico SDK configurado  </li> <li>Alimentaci\u00f3n (a trav\u00e9s del puerto USB del Pico)  </li> </ul>"},{"location":"practicas/sumador/#1-objetivos","title":"1) Objetivos","text":"<ul> <li> <p>Objetivos de la pr\u00e1ctica</p> </li> <li> <p>Comprender el uso de salidas digitales en el microcontrolador Configurar los pines GPIO del Raspberry Pi Pico como salidas para controlar LEDs.</p> </li> <li> <p>Implementar un contador binario en hardware Representar en 4 LEDs la cuenta de 0 a 15, utilizando operaciones l\u00f3gicas y m\u00e1scaras para manipular bits.</p> </li> <li> <p>Aplicar l\u00f3gica de desplazamiento y enmascaramiento Utilizar operadores bit a bit (&lt;&lt;, &amp;, |) para mapear valores binarios a los pines seleccionados del microcontrolador.</p> </li> <li> <p>Familiarizarse con el control de tiempo en programas embebidos Manejar retardos en milisegundos para visualizar la secuencia del contador en los LEDs.</p> </li> <li> <p>Relacionar teor\u00eda con pr\u00e1ctica Observar c\u00f3mo los n\u00fameros en base binaria se traducen en encendidos y apagados de LEDs, reforzando el entendimiento de la representaci\u00f3n binaria en sistemas digitales.</p> </li> </ul>"},{"location":"practicas/sumador/#2-circuito","title":"2) Circuito","text":"<p>La siguiente imagen muestra las conexiones realizadas, se utilizaron 4 resistencias de 220 ohms y 4 leds rojos </p> <p></p> <p></p>"},{"location":"practicas/sumador/#3-codigo","title":"3) Codigo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#define A 12\n#define B 13    \n#define C 14\n#define D 15\n\nconst uint32_t LED_MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C) | (1u &lt;&lt; D) ;\n\n\nint main() {\n    stdio_init_all();\n    gpio_init_mask(LED_MASK);\n    gpio_set_dir_out_masked(LED_MASK);\n    gpio_put_masked(LED_MASK, 0);\n\n    while (true) {\n\n        for (uint32_t n = 0; n &lt; 16; n++) {\n            gpio_put_masked(LED_MASK, n&lt;&lt;12);\n            sleep_ms(1000);\n        } \n       /* gpio_put_masked(LED_MASK, LED_MASK);*/\n    }\n    return 0;\n}\n</code></pre>"},{"location":"practicas/sumador/#4-explicacion-del-programa","title":"4) Explicaci\u00f3n del programa","text":"<p>Explicaci\u00f3n del c\u00f3digo</p> <p>Este programa implementa un contador binario de 4 bits en un Raspberry Pi Pico usando los GPIO 12\u201315 para controlar cuatro LEDs.</p> <p>Definiciones y m\u00e1scara <pre><code>#define A 12\n#define B 13\n#define C 14\n#define D 15\n\nconst uint32_t LED_MASK = (1u &lt;&lt; A) | (1u &lt;&lt; B) | (1u &lt;&lt; C) | (1u &lt;&lt; D);\n</code></pre></p> <p>Se asignan nombres a los pines.</p> <p>La m\u00e1scara (LED_MASK) permite configurar y escribir en todos los pines a la vez. <pre><code>Inicializaci\u00f3n\ngpio_init_mask(LED_MASK);\ngpio_set_dir_out_masked(LED_MASK);\ngpio_put_masked(LED_MASK, 0);\n</code></pre></p> <p>Inicializa los pines 12\u201315, los configura como salida y los apaga. <pre><code>Bucle principal\nfor (uint32_t n = 0; n &lt; 16; n++) {\n    gpio_put_masked(LED_MASK, n &lt;&lt; 12);\n    sleep_ms(1000);\n}\n</code></pre> Recorre los valores de 0 a 15 (0000\u20131111 en binario).</p> <p>n &lt;&lt; 12 alinea el n\u00famero con los GPIO 12\u201315.</p> <p>Cada segundo se actualiza el estado de los LEDs mostrando el conteo binario.</p>"},{"location":"practicas/sumador/#5-video-del-funcionamiento","title":"5) Video del Funcionamiento:","text":""},{"location":"practicas/sumador/#demostracion-en-video","title":"Demostraci\u00f3n en video","text":""},{"location":"practicas/PWM/control_pwm/","title":"Control de PWM","text":"Perif\u00e9ricos, Memoria, Ecosistema, Costos, Arquitectura y Velocidad de Trabajo"},{"location":"practicas/PWM/control_pwm/#informacion","title":"Informacion","text":"<ul> <li>Nombre del proyecto: Control de pwm con Raspberry Pico</li> <li>Equipo / Autor(es): Antonio Mart\u00ednez</li> <li>Curso / Asignatura: Sistemas Embebidos</li> <li>Fecha: 23/08/2025</li> <li>Descripci\u00f3n breve: Implementaci\u00f3n de un sistema de generaci\u00f3n de audio con buzzer pasivo usando control PWM en el microcontrolador RP2040 (Raspberry Pi Pico). Se documentan los perif\u00e9ricos utilizados y se ubica al RP2040 en una comparativa con otros MCUs.</li> </ul>"},{"location":"practicas/PWM/control_pwm/#introduccion-control-pwm","title":"Introducci\u00f3n: Control PWM","text":"<p>En este proyecto se emplea el m\u00f3dulo PWM (Pulse Width Modulation) del microcontrolador RASPBERRY PICO para generar se\u00f1ales de audio en un buzzer pasivo. El principio consiste en variar la frecuencia de la se\u00f1al cuadrada enviada al buzzer, de manera que \u00e9ste reproduzca diferentes notas musicales.  </p> <p>El c\u00f3digo define una lista de notas (frecuencias en Hz) y figuras r\u00edtmicas (divisiones de tiempo), que son enviadas al perif\u00e9rico PWM del RP2040 para reproducir una melod\u00eda.  </p> <p>Este enfoque demuestra c\u00f3mo los perif\u00e9ricos de un microcontrolador pueden ser usados no solo para control de motores o regulaci\u00f3n de voltaje, sino tambi\u00e9n para la generaci\u00f3n de sonidos y m\u00fasica digital.</p>"},{"location":"practicas/PWM/control_pwm/#perifericos","title":"Perif\u00e9ricos","text":"<ul> <li>RASPBERRY PICO     Se utiliza la Raspberry Pi Pico porque integra el microcontrolador RP2040, que cuenta con perif\u00e9ricos PWM de hardware dedicados. Esto permite generar se\u00f1ales de modulaci\u00f3n por ancho de pulso de manera precisa y eficiente, sin sobrecargar el procesador principal. Adem\u00e1s, la Pico es econ\u00f3mica, f\u00e1cil de programar y ampliamente soportada por la comunidad, lo que facilita el desarrollo y la depuraci\u00f3n de proyectos de control de se\u00f1ales como este.</li> </ul>"},{"location":"practicas/PWM/control_pwm/#ecosistema","title":"Ecosistema","text":"<p>El RP2040 cuenta con un ecosistema creciente y robusto:  </p> <ul> <li>Lenguajes soportados: C/C++ (usando SDK oficial) y MicroPython.  </li> <li>IDE y entornos comunes: VSCode, Thonny, Arduino IDE (con soporte agregado).  </li> </ul>"},{"location":"practicas/PWM/control_pwm/#velocidad-de-trabajo","title":"Velocidad de Trabajo","text":"<ul> <li>La Pico opera a 150 MHz, lo cual resulta sobrado para generar PWM de audio.  </li> <li>El c\u00e1lculo del divisor para el perif\u00e9rico PWM (<code>pwm_set_clkdiv_int_frac()</code>) se hace r\u00e1pidamente gracias a la alta frecuencia de reloj.  </li> <li>En este proyecto, la frecuencia m\u00e1xima usada fue ~2 kHz (notas musicales), muy por debajo del l\u00edmite real del microcontrolador.  </li> </ul>"},{"location":"practicas/PWM/control_pwm/#codigo-del-buzzer","title":"Codigo del buzzer","text":"<p>```c</p> <pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define BUZZER_PIN 15\n#define BPM 200           \n#define GAP_MS 12\n\n// notes en hz\n#define NOTE_B0  31\n#define NOTE_C1  33\n#define NOTE_CS1 35\n#define NOTE_D1  37\n#define NOTE_DS1 39\n#define NOTE_E1  41\n#define NOTE_F1  44\n#define NOTE_FS1 46\n#define NOTE_G1  49\n#define NOTE_GS1 52\n#define NOTE_A1  55\n#define NOTE_AS1 58\n#define NOTE_B1  62\n#define NOTE_C2  65\n#define NOTE_CS2 69\n#define NOTE_D2  73\n#define NOTE_DS2 78\n#define NOTE_E2  82\n#define NOTE_F2  87\n#define NOTE_FS2 93\n#define NOTE_G2  98\n#define NOTE_GS2 104\n#define NOTE_A2  110\n#define NOTE_AS2 117\n#define NOTE_B2  123\n#define NOTE_C3  131\n#define NOTE_CS3 139\n#define NOTE_D3  147\n#define NOTE_DS3 156\n#define NOTE_E3  165\n#define NOTE_F3  175\n#define NOTE_FS3 185\n#define NOTE_G3  196\n#define NOTE_GS3 208\n#define NOTE_A3  220\n#define NOTE_AS3 233\n#define NOTE_B3  247\n#define NOTE_C4  262\n#define NOTE_CS4 277\n#define NOTE_D4  294\n#define NOTE_DS4 311\n#define NOTE_E4  330\n#define NOTE_F4  349\n#define NOTE_FS4 370\n#define NOTE_G4  392\n#define NOTE_GS4 415\n#define NOTE_A4  440\n#define NOTE_AS4 466\n#define NOTE_B4  494\n#define NOTE_C5  523\n#define NOTE_CS5 554\n#define NOTE_D5  587\n#define NOTE_DS5 622\n#define NOTE_E5  659\n#define NOTE_F5  698\n#define NOTE_FS5 740\n#define NOTE_G5  784\n#define NOTE_GS5 831\n#define NOTE_A5  880\n#define NOTE_AS5 932\n#define NOTE_B5  988\n#define NOTE_C6  1047\n#define NOTE_CS6 1109\n#define NOTE_D6  1175\n#define NOTE_DS6 1245\n#define NOTE_E6  1319\n#define NOTE_F6  1397\n#define NOTE_FS6 1480\n#define NOTE_G6  1568\n#define NOTE_GS6 1661\n#define NOTE_A6  1760\n#define NOTE_AS6 1865\n#define NOTE_B6  1976\n\n#define REST 0\n\n// ====== Figuras (divisor del pulso) ======\n// Duraci\u00f3n real (ms) = (60000 / BPM) * 4 / FIG\n#define W   1   // redonda (4 tiempos)\n#define H   2   // blanca   (2 tiempos)\n#define Q   4   // negra    (1 tiempo)\n#define E   8   // corchea  (1/2)\n#define S   16  // semicor. (1/4)\n#define T32 32  // fusa\n\n// ====== PWM helper ======\nstatic void pwm_set_freq_duty(uint pin, uint32_t freq, float duty_percent) {\n    gpio_set_function(pin, GPIO_FUNC_PWM); // seteamos la funcion del pin a PWM\n    uint slice = pwm_gpio_to_slice_num(pin); //Cambiar la funcioin de GPIO a PWM\n    uint chan  = pwm_gpio_to_channel(pin); //Asignamos el canal\n\n    if (freq == 0) {\n        pwm_set_enabled(slice, false);\n        return;\n    }\n\n    //Aqui empezamos a calcular el divisor\n\n    uint32_t f_sys = 150000000u; // la frecuencia del pico\n    uint32_t top = 4095; // aqui pensamos esto para usar 12 bits, pues tenemos la formula log2(top +1)\n    float div = (float)f_sys / (freq * (top + 1));\n\n    //esto es solo por si se sale de rano el divisor\n    if (div &lt; 1.0f) div = 1.0f;          // l\u00edmite inferior ( pues solo tiene un rango el pwm de 1 a 255)\n    if (div &gt; 255.0f) div = 255.0f;      // l\u00edmite superior\n\n    uint32_t div_int  = (uint32_t)div; //dividimos div en su parte entera\n    uint32_t div_frac = (uint32_t)((div - div_int) * 16.0f); // y esta es su parte fraccionaria\n    //basicamente se define div que se usar\u00e1\n\n\n    pwm_set_clkdiv_int_frac(slice, div_int, div_frac); //seteamos el divisor, esta es como la funcion pwm_set_clkdiv pero con parte fraccionaria\n    pwm_set_wrap(slice, top);//seteamos el top\n\n    uint32_t level = (uint32_t)(duty_percent * 0.01f * (top + 1));\n    pwm_set_chan_level(slice, chan, level);\n    pwm_set_enabled(slice, true);\n}\n\nstatic inline uint32_t ms_per_whole(void) {\n    // para la duracion de una redonda \n    return (60000u / BPM) * 4u;\n}\n\nstatic void play(uint32_t freq, uint32_t figure_div) {\n    uint32_t dur_ms = ms_per_whole() / figure_div;\n    if (freq == REST) {\n        pwm_set_freq_duty(BUZZER_PIN, 0, 0);\n        sleep_ms(dur_ms);\n    } else {\n        pwm_set_freq_duty(BUZZER_PIN, freq, 50.0f);\n\n        sleep_ms(dur_ms);\n        pwm_set_freq_duty(BUZZER_PIN, 0, 0);\n\n    }\n}\n\n\nstatic const uint16_t melody[] = {\n    // Frase A\n    NOTE_D4, NOTE_D4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4, \n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //B\n    NOTE_C4, NOTE_C4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //C\n    NOTE_A3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //D \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n\n    //REPEAT 2\n    NOTE_D4, NOTE_D4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4, \n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //B\n    NOTE_C4, NOTE_C4, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //C\n    NOTE_A3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    //D \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n\n    //siguiente f   \n    NOTE_AS3, NOTE_A3, NOTE_D5,\n    NOTE_A4, REST, NOTE_GS4,\n    REST, NOTE_G4, NOTE_F4,\n    NOTE_F4, NOTE_D4, NOTE_F4, NOTE_G4,\n    // G\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //H\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //x2\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n    //H\n    NOTE_C5, NOTE_C5, NOTE_C6,\n    NOTE_A4, REST, NOTE_GS6,REST,\n    NOTE_G5, NOTE_F5,\n    NOTE_F5,NOTE_C5,NOTE_F5,NOTE_G5,\n\n\n\n\n\n};\n\nstatic const uint8_t rhythm[] = {\n    // Frase A\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    /// Frase B\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE C\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE D\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n\n    //REPEAT 2\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    /// Frase B\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE C\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //FRASE D\n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    //siguiente f   \n    E, E, Q,  \n    E, E, Q,\n    Q, E, E, \n    E,Q,E,\n    E,E,E,E,\n    // G\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //H\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //x2\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E,\n    //H\n    E,E,Q,\n    Q,E,E,E,\n    Q,E,\n    E,E,E,E\n\n\n\n\n\n};\n\n\n// ====== main ======\nint main() {\n    stdio_init_all();\n    gpio_init(BUZZER_PIN);\n    gpio_set_dir(BUZZER_PIN, true);\n\n    const int notes = sizeof(melody) / sizeof(melody[0]);\n\n    while (true) {\n        for (int i = 0; i &lt; notes; ++i) {\n            play(melody[i], rhythm[i]);\n        }\n        sleep_ms(800);  // breve pausa antes de repetir\n    }\n    return 0;\n}\n</code></pre>"},{"location":"practicas/PWM/control_pwm/#explicacion","title":"Explicaci\u00f3n","text":""},{"location":"practicas/PWM/control_pwm/#que-hace-playfreq-figure_div","title":"\u00bfQu\u00e9 hace <code>play(freq, figure_div)</code>?","text":"<p>Funci\u00f3n que toca una nota (o un silencio) en un buzzer mediante PWM durante el tiempo correspondiente a la figura r\u00edtmica.</p>"},{"location":"practicas/PWM/control_pwm/#parametros","title":"Par\u00e1metros","text":"<ul> <li><code>freq</code>: frecuencia de la nota en Hz. Si es <code>REST</code>, se reproduce silencio.</li> <li><code>figure_div</code>: divisor de la figura musical (1=redonda, 2=blanca, 4=negra, 8=corchea, etc.).</li> </ul>"},{"location":"practicas/PWM/control_pwm/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<ol> <li>Duraci\u00f3n: calcula <code>dur_ms = ms_per_whole() / figure_div</code>, usando el BPM para obtener la duraci\u00f3n de una redonda y dividirla por la figura indicada.</li> <li>Silencio (REST):</li> <li>Si <code>freq == REST</code>, apaga el PWM (<code>pwm_set_freq_duty(..., 0, 0)</code>) y espera <code>dur_ms</code>.</li> <li>Nota:</li> <li>Enciende el PWM con la frecuencia <code>freq</code> y duty 50% (<code>pwm_set_freq_duty(BUZZER_PIN, freq, 50.0f)</code>), generando una onda cuadrada sim\u00e9trica.</li> <li>Mantiene la nota con <code>sleep_ms(dur_ms)</code>.</li> <li>Apaga el PWM al final para garantizar silencio.</li> </ol>"},{"location":"practicas/PWM/control_pwm/#claves","title":"Claves","text":"<ul> <li>La frecuencia define el pitch (altura de la nota).</li> <li>El duty 50% ofrece buen equilibrio de volumen/timbre para un buzzer pasivo.</li> <li>Implementaci\u00f3n bloqueante: <code>sleep_ms(...)</code> detiene la CPU durante la nota/silencio.</li> <li>Versi\u00f3n m\u00ednima: no incluye micro-silencios de articulaci\u00f3n ni envolventes (ataque/decay).</li> </ul>"},{"location":"practicas/PWM/control_pwm/#referencias","title":"Referencias","text":""},{"location":"practicas/PWM/control_pwm/#video","title":"Video","text":"<ul> <li>Raspberry Pi Ltd. (2025). RP2040 Datasheet. Disponible en: https://www.raspberrypi.com/documentation/microcontrollers/rp2040.html </li> <li>C\u00f3digo de pr\u00e1ctica en C (PWM con buzzer), desarrollado por el autor (2025).  </li> <li>Espressif Systems, STMicroelectronics, NXP, Microchip, Texas Instruments \u2013 Datasheets oficiales de referencia.  </li> </ul>"},{"location":"practicas/PWM/pwm_motor/","title":"Control de motor DC por PWM (3 velocidades) con botones (Raspberry Pi Pico + TB6612FNG)","text":"<p>Este proyecto controla la velocidad de un motor DC mediante PWM usando un Raspberry Pi Pico/Pico 2 y el driver TB6612FNG. Dos botones (SUBIR/BAJAR) cambian entre tres niveles de velocidad predefinidos. El PWM trabaja a 20 kHz (fuera del rango audible).</p>"},{"location":"practicas/PWM/pwm_motor/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Motor DC PWM 3 velocidades </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/10/2025 </li> <li>Descripci\u00f3n breve: Control de un motor DC con TB6612FNG usando PWM (20 kHz) y dos botones con _pull-up interno para seleccionar 3 niveles de velocidad (70%, 80%, 90%)._  </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>hardware/pwm.h</code>). T\u00e9cnicas clave: PWM (20 kHz), c\u00e1lculo de <code>clkdiv</code> y <code>wrap</code>, debounce por software, lectura de GPIO con pull-up y detecci\u00f3n de flanco. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"practicas/PWM/pwm_motor/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) y cable USB  </li> <li>Driver TB6612FNG </li> <li>Motor DC (compatible con la tensi\u00f3n de VM y corriente del driver)  </li> <li>Fuente de VM (ej. 5\u201312 V seg\u00fan motor)  </li> <li>2 botones moment\u00e1neos (a GND, sin resistencias externas gracias al pull-up interno)  </li> <li>Protoboard y jumpers</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM a 20 kHz sobre un pin GPIO para modular la velocidad del motor.  </li> <li>Implementar tres velocidades predefinidas con cambios mediante dos botones (subir/bajar).  </li> <li>Aplicar debounce por software y detecci\u00f3n de flanco 1\u21920.  </li> <li>Fijar direcci\u00f3n de giro con pines AIN1/AIN2 (TB6612FNG).</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Notas generales (TB6612FNG): - PWMA controla el canal A (ancho de pulso). - AIN1/AIN2 fijan la direcci\u00f3n del canal A. - AO1/AO2 salen al motor. - VM: alimentaci\u00f3n del motor (p. ej. 6\u201312 V). - VCC: 3V3 l\u00f3gicos desde el Pico. - GND com\u00fan entre Pico, TB6612 y la fuente del motor. - STBY: mantener en alto (3V3) para habilitar el driver.</p> <p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al (Pico) GPIO TB6612FNG Descripci\u00f3n <code>PWM_PIN</code> 0 PWMA PWM 20 kHz (control de velocidad) <code>DIR1_PIN</code> 16 AIN1 Direcci\u00f3n (bit 1) <code>DIR2_PIN</code> 17 AIN2 Direcci\u00f3n (bit 2) <code>BTN_DOWN_PIN</code> 2 \u2014 Bot\u00f3n BAJAR (a GND, pull-up) <code>BTN_UP_PIN</code> 3 \u2014 Bot\u00f3n SUBIR (a GND, pull-up) <p>Botones (activos en bajo): - Un terminal del bot\u00f3n a GND; el otro a GPIO 2 (BAJAR) o GPIO 3 (SUBIR). - Se habilita <code>gpio_pull_up()</code>, por lo que al presionar: 0 l\u00f3gico.</p> <p>Direcci\u00f3n fija (ejemplo): - <code>AIN1=1</code> y <code>AIN2=0</code> (definido en el c\u00f3digo) \u2192 giro adelante. - Para invertir el giro: intercambia los valores o cablea al rev\u00e9s.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"practicas/PWM/pwm_motor/#4-codigo","title":"4) C\u00f3digo","text":"<p>```c     // dc_motor_pwm.c \u2014 Control de motor DC con 3 velocidades (baja/media/alta)     // Raspberry Pi Pico / Pico 2 + TB6612FNG (ejemplo)     // PWM en GPIO15 \u2192 PWMA; Direcci\u00f3n: AIN1 (GPIO16), AIN2 (GPIO17)     // Botones a GND con pull-up interno: BTN_DOWN(GPIO13), BTN_UP(GPIO14)</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n// ----------------- Pines -----------------\n#define PWM_PIN      0       // PWMA (TB6612)\n#define DIR1_PIN     16     // AIN1\n#define DIR2_PIN     17     // AIN2\n#define BTN_DOWN_PIN 2     // Bot\u00f3n: bajar velocidad\n#define BTN_UP_PIN   3     // Bot\u00f3n: subir velocidad\n\n// ----------------- PWM -------------------\n#define F_PWM_HZ  20000     // 20 kHz: fuera de audio\n#define TOP       1023      // 10 bits de resoluci\u00f3n (0..1023)\n\n// ----------------- Debounce --------------\n#define DEBOUNCE_MS 30\n\nint main() {\n    stdio_init_all();\n\n// --- Direcci\u00f3n: adelante (AIN1=1, AIN2=0) ---\ngpio_init(DIR1_PIN); gpio_set_dir(DIR1_PIN, GPIO_OUT); gpio_put(DIR1_PIN, 1);\ngpio_init(DIR2_PIN); gpio_set_dir(DIR2_PIN, GPIO_OUT); gpio_put(DIR2_PIN, 0);\n\n// --- Botones con pull-up interno (activos en 0) ---\ngpio_init(BTN_DOWN_PIN); gpio_set_dir(BTN_DOWN_PIN, GPIO_IN); gpio_pull_up(BTN_DOWN_PIN);\ngpio_init(BTN_UP_PIN);   gpio_set_dir(BTN_UP_PIN,   GPIO_IN); gpio_pull_up(BTN_UP_PIN);\n\n// --- PWM en el pin de control de velocidad ---\ngpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\nuint slice = pwm_gpio_to_slice_num(PWM_PIN);\nuint chan  = pwm_gpio_to_channel(PWM_PIN);\n\nfloat f_clk = 150000000.0f;                         // 125 MHz\nfloat div   = f_clk / (F_PWM_HZ * (TOP + 1));       // clkdiv flotante\npwm_set_clkdiv(slice, div);\npwm_set_wrap(slice, TOP);\n\npwm_set_chan_level(slice, chan, 0);                 // arranque detenido\npwm_set_enabled(slice, true);\n\n// --- Tabla de 3 velocidades (duty) ---\n// Baja=35%, Media=65%, Alta=90%\nuint16_t speed_levels[] = {\n    (uint16_t)(TOP * 0.70f),\n    (uint16_t)(TOP * 0.80f),\n    (uint16_t)(TOP * 0.90f)\n};\nconst int NUM_SPEEDS = 3;\n\nint idx = 0; // \u00edndice de velocidad actual (0=baja)\nuint32_t t_last_down = 0, t_last_up = 0;\nint last_down = 1, last_up = 1; // estados anteriores (con pull-up, reposo=1)\n\n// Aplica velocidad inicial\npwm_set_chan_level(slice, chan, speed_levels[idx]);\n\nwhile (true) {\n    // --- Leer botones (con edge + debounce) ---\n    int cur_down = gpio_get(BTN_DOWN_PIN);\n    int cur_up   = gpio_get(BTN_UP_PIN);\n    uint32_t now = to_ms_since_boot(get_absolute_time());\n\n    // Bot\u00f3n DOWN: flanco de 1-&gt;0\n    if (last_down == 1 &amp;&amp; cur_down == 0 &amp;&amp; (now - t_last_down) &gt; DEBOUNCE_MS) {\n        if (idx &gt; 0) idx--;\n        pwm_set_chan_level(slice, chan, speed_levels[idx]);\n        t_last_down = now;\n    }\n    // Bot\u00f3n UP: flanco de 1-&gt;0\n    if (last_up == 1 &amp;&amp; cur_up == 0 &amp;&amp; (now - t_last_up) &gt; DEBOUNCE_MS) {\n        if (idx &lt; (NUM_SPEEDS - 1)) idx++;\n        pwm_set_chan_level(slice, chan, speed_levels[idx]);\n        t_last_up = now;\n    }\n\n    last_down = cur_down;\n    last_up   = cur_up;\n\n    sleep_ms(5);\n}\n</code></pre> <p>}</p>"},{"location":"practicas/PWM/pwm_motor/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/PWM/pwm_motor/#a-configuracion-de-pwm-20-khz-10-bits","title":"a) Configuraci\u00f3n de PWM (20 kHz, 10 bits)","text":"<ul> <li><code>F_PWM_HZ = 20000</code> y <code>TOP = 1023</code> \u2192 resoluci\u00f3n de 10 bits (0..1023).</li> <li>Se calcula <code>clkdiv</code> con <code>div = f_clk / (F_PWM_HZ * (TOP + 1))</code>.</li> <li>Nota: En el c\u00f3digo <code>f_clk = 150e6</code> con comentario \u201c125 MHz\u201d. Ajusta el valor si tu reloj es 125 MHz (<code>125000000.0f</code>) o deja 150 MHz si realmente configuraste el PLL a esa frecuencia.</li> <li><code>pwm_set_wrap(slice, TOP)</code> y <code>pwm_set_clkdiv(slice, div)</code> fijan la frecuencia.</li> <li><code>pwm_set_chan_level(slice, chan, duty)</code> actualiza el ciclo de trabajo.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#b-direccion-del-motor-tb6612fng","title":"b) Direcci\u00f3n del motor (TB6612FNG)","text":"<ul> <li>Se fuerza adelante con <code>AIN1=1</code>, <code>AIN2=0</code>.</li> <li>Para invertir el giro: <code>AIN1=0</code>, <code>AIN2=1</code>. No uses <code>0/0</code> (rueda libre) ni <code>1/1</code> (freno) salvo intencionalmente.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#c-botones-con-pull-up-y-debounce","title":"c) Botones con pull-up y debounce","text":"<ul> <li><code>BTN_DOWN_PIN</code> (GPIO 2) y <code>BTN_UP_PIN</code> (GPIO 3) como entradas con <code>gpio_pull_up()</code>.</li> <li>Se detecta flanco 1\u21920 (presi\u00f3n) comparando estado previo/actual.</li> <li>Debounce: <code>DEBOUNCE_MS = 30</code> ms por bot\u00f3n con marcas de tiempo (<code>to_ms_since_boot</code>).</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#d-tabla-de-velocidades","title":"d) Tabla de velocidades","text":"<ul> <li>Niveles en <code>speed_levels[]</code>: 70%, 80%, 90% del <code>TOP</code>.</li> <li>Nota: El comentario dice \u201c35/65/90%\u201d, pero el c\u00f3digo actual aplica 70/80/90%. Cambia los coeficientes <code>0.70f, 0.80f, 0.90f</code> si deseas otros niveles (p. ej., <code>0.35f, 0.65f, 0.90f</code>).</li> <li><code>idx</code> selecciona el nivel. Los botones BAJAR/SUBIR decrementan/incrementan <code>idx</code> dentro de <code>[0, NUM_SPEEDS-1]</code>.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#e-bucle-principal","title":"e) Bucle principal","text":"<ul> <li>Lee botones, aplica debounce, actualiza <code>idx</code> si hay flanco v\u00e1lido y reprograma el duty con <code>pwm_set_chan_level</code>.</li> <li><code>sleep_ms(5)</code> fija la cadencia de sondeo (~200 Hz), suficiente para la interfaz de botones.</li> </ul>"},{"location":"practicas/PWM/pwm_motor/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Arranque: motor en marcha a la velocidad 0 (70%).</li> <li>Bot\u00f3n SUBIR (GPIO 3): incrementa a 80% y luego 90%.</li> <li>Bot\u00f3n BAJAR (GPIO 2): decrementa hacia 80% y 70%.</li> <li>Debounce estable: pulsaciones r\u00e1pidas no deben generar m\u00faltiples cambios espurios.</li> <li>Silencio el\u00e9ctrico: PWM a 20 kHz evita zumbidos audibles en la mayor\u00eda de motores.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/","title":"Senoide aproximada de 60 Hz por PWM (Raspberry Pi Pico)","text":"<p>Este proyecto genera una se\u00f1al senoidal \u201cpromediada\u201d de 60 Hz modulando el duty cycle de una portadora PWM a 40 kHz (10 bits). Se actualiza el duty en 128 muestras por ciclo, logrando un valor medio (tras filtrado o por inercia de la carga) que sigue una senoide. \u00datil para pruebas de filtrado RC, control de potencia (baja tensi\u00f3n) o caracterizaci\u00f3n de etapas H-bridge (aisladas). No conectar a la red el\u00e9ctrica.</p>"},{"location":"practicas/PWM/seno_pwm/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: PWM \u2192 senoide de 60 Hz </li> <li>Equipo / Autor(es): Antonio Mart\u00ednez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 01/10/2025 </li> <li>Descripci\u00f3n breve: S\u00edntesis de una senoide de 60 Hz mediante modulaci\u00f3n del duty de un PWM a 40 kHz con 10 bits y 128 muestras por ciclo. Timing con <code>sleep_until()</code> para reducir jitter. </li> </ul> <p>Informaci\u00f3n del proyecto:</p> <p>Lenguaje/SDK: C con Raspberry Pi Pico SDK (<code>pico/stdlib.h</code>, <code>pico/time.h</code>, <code>hardware/pwm.h</code>). T\u00e9cnicas clave: PWM de alta frecuencia, tabla/muestreo senoidal, temporizaci\u00f3n absoluta (bajo jitter), cuantizaci\u00f3n 10 bits. Plataforma: Raspberry Pi Pico / Pico 2.  </p>"},{"location":"practicas/PWM/seno_pwm/#material-utilizado","title":"Material utilizado","text":"<ul> <li>Raspberry Pi Pico (o Pico 2) y cable USB  </li> <li>Protoboard y jumpers  </li> <li>(Opcional) Filtro RC pasabajas (p. ej., R=1\u20134.7 k\u03a9, C=4.7\u201310 \u00b5F) para recuperar la senoide promedio  </li> <li>(Opcional) Osciloscopio para visualizar portadora y se\u00f1al filtrada  </li> <li>(Si se usa potencia) Etapa H-bridge/l\u00ednea aislada, nunca a red AC</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>Configurar PWM a 40 kHz con 10 bits de resoluci\u00f3n.  </li> <li>Generar una senoide de 60 Hz modulando el duty con 128 muestras/ciclo.  </li> <li>Usar temporizaci\u00f3n absoluta (<code>sleep_until</code>) para minimizar jitter de muestreo.  </li> <li>Controlar amplitud (<code>AMP_PCT</code>) y offset DC (<code>DC_OFFSET</code>) de la se\u00f1al promediada.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#3-conexiones-esquema","title":"3) Conexiones / Esquema","text":"<p>Mapeo de pines (seg\u00fan el c\u00f3digo):</p> Se\u00f1al (Pico) GPIO Descripci\u00f3n <code>PWM_PIN</code> 15 Salida PWM (portadora 40 kHz, duty variable) <code>GND</code> \u2014 Referencia com\u00fan <p>Notas de conexi\u00f3n: - Para observar la senoide promedio, conecta <code>PWM_PIN</code> a un filtro RC pasabajas y mide en la salida del filtro respecto a GND. - Ajusta el corte del RC (p. ej., 300\u2013800 Hz) para atenuar la portadora (40 kHz) preservando 60 Hz.</p> <p>Diagrama de conexi\u00f3n </p>"},{"location":"practicas/PWM/seno_pwm/#4-codigo","title":"4) C\u00f3digo","text":"<pre><code>```c\n// pwm_sine_60hz.c \u2014 Senoide aproximada de 60 Hz modulando el duty del PWM\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define PWM_PIN             15      // GPIO de salida PWM\n#define F_PWM_HZ            40000   // Portadora PWM (40 kHz, fuera de audio)\n#define TOP                 1023    // 10 bits de resoluci\u00f3n\n\n#define SINE_FREQ_HZ        60      // Frecuencia de la senoide \u201cpromediada\u201d\n#define SAMPLES_PER_CYCLE   128     // Muestras por ciclo de seno\n#define AMP_PCT             0.98f   // Amplitud relativa (0..1)\n#define DC_OFFSET           0.50f   // Offset DC relativo (0.5 = centrado)\n\nint main() {\n    stdio_init_all();\n\n    // --- Configurar PWM en el pin ---\n    gpio_set_function(PWM_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(PWM_PIN);\n    uint chan  = pwm_gpio_to_channel(PWM_PIN);\n\n    // Calcular divisor para la portadora\n    float f_clk = 125000000.0f;                    // 125 MHz\n    float div   = f_clk / (F_PWM_HZ * (TOP + 1));  // clkdiv flotante\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // --- Generaci\u00f3n de seno por software (duty = sin()) ---\n    const float fs = (float)SINE_FREQ_HZ * (float)SAMPLES_PER_CYCLE;   // tasa de actualizaci\u00f3n\n    const uint32_t Ts_us = (uint32_t)lrintf(1000000.0f / fs);          // periodo de muestreo en us\n\n    float phase = 0.0f;\n    const float phase_step = 2.0f * (float)M_PI / (float)SAMPLES_PER_CYCLE;\n\n    // Reloj base para minimizar jitter\n    absolute_time_t t = delayed_by_us(get_absolute_time(), Ts_us);\n\n    while (true) {\n        // s \u2208 [-1,1] \u2192 u \u2208 [0,1] con offset y amplitud\n        float s = sinf(phase);\n        float u = DC_OFFSET + 0.5f * AMP_PCT * s;\n        if (u &lt; 0.0f) u = 0.0f; if (u &gt; 1.0f) u = 1.0f;\n\n        uint16_t level = (uint16_t)lrintf(u * (float)TOP);\n        pwm_set_chan_level(slice, chan, level);\n\n        // Avanzar fase y temporizaci\u00f3n precisa\n        phase += phase_step;\n        if (phase &gt;= 2.0f * (float)M_PI) phase -= 2.0f * (float)M_PI;\n\n        sleep_until(t);\n        t = delayed_by_us(t, Ts_us);\n    }\n}\n</code></pre>"},{"location":"practicas/PWM/seno_pwm/#5-explicacion-del-programa","title":"5) Explicaci\u00f3n del programa","text":""},{"location":"practicas/PWM/seno_pwm/#a-portadora-pwm-40-khz-10-bits","title":"a) Portadora PWM (40 kHz, 10 bits)","text":"<ul> <li><code>F_PWM_HZ = 40000</code> y <code>TOP = 1023</code> \u2192 10 bits (niveles 0..1023).</li> <li>Frecuencia de PWM mediante <code>div = f_clk / (F_PWM_HZ*(TOP+1))</code> con <code>f_clk = 125 MHz</code>.</li> <li><code>pwm_set_wrap(slice, TOP)</code> define el conteo y <code>pwm_set_clkdiv(slice, div)</code> ajusta el preescalador.</li> <li>El duty se actualiza con <code>pwm_set_chan_level(slice, chan, level)</code>.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#b-senoide-promedio-de-60-hz-muestreo-a-768-khz","title":"b) Senoide \u201cpromedio\u201d de 60 Hz (muestreo a 7.68 kHz)","text":"<ul> <li><code>SINE_FREQ_HZ = 60</code>, <code>SAMPLES_PER_CYCLE = 128</code> \u2192 <code>fs = 60\u00d7128 = 7680 Hz</code>.</li> <li>Periodo de muestra: <code>Ts_us \u2248 1e6 / 7680 \u2248 130.21 \u00b5s</code> (redondeado con <code>lrintf</code>).</li> <li>Se incrementa la fase en <code>phase_step = 2\u03c0/128</code> por muestra y se calcula <code>u = DC_OFFSET + 0.5\u00b7AMP_PCT\u00b7sin(phase)</code> limitado a <code>[0,1]</code>.</li> <li><code>u</code> se mapea a 10 bits: <code>level = round(u\u00b7TOP)</code>.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#c-temporizacion-precisa-bajo-jitter","title":"c) Temporizaci\u00f3n precisa (bajo jitter)","text":"<ul> <li>Se emplea un reloj absoluto: <code>sleep_until(t); t = delayed_by_us(t, Ts_us);</code> en vez de <code>sleep_us(Ts_us)</code>.</li> <li>Esto mantiene un periodo constante de actualizaci\u00f3n de duty, reduciendo el jitter de muestreo.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#d-control-de-amplitud-y-offset","title":"d) Control de amplitud y offset","text":"<ul> <li><code>AMP_PCT</code> (0..1) escala la amplitud pico a pico de la senoide promedio (aqu\u00ed 98%).</li> <li><code>DC_OFFSET = 0.5</code> centra la se\u00f1al en 50% de duty (salida bipolar tras filtro/etapa diferencial).</li> <li>Para una salida puramente unipolar filtrada, mantiene <code>DC_OFFSET \u2265 AMP_PCT/2</code>.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#e-recuperacion-de-la-senoide-filtro","title":"e) Recuperaci\u00f3n de la senoide (filtro)","text":"<ul> <li>Para observar una senoide limpia, usa un filtro pasabajas (p. ej., RC con <code>fc\u2248300\u2013800 Hz</code>).</li> <li>La portadora a 40 kHz queda muy atenuada; se conserva la envolvente de 60 Hz.</li> </ul>"},{"location":"practicas/PWM/seno_pwm/#6-pruebas-y-comportamiento-esperado","title":"6) Pruebas y comportamiento esperado","text":"<ul> <li>Osciloscopio (PWM crudo): tren a 40 kHz cuyo duty va oscilando suavemente.</li> <li>Tras RC: se\u00f1al aproximada a senoide 60 Hz; amplitud depende de <code>AMP_PCT</code>, offset seg\u00fan <code>DC_OFFSET</code>.</li> <li>Estabilidad temporal: la frecuencia de 60 Hz es estable por el uso de <code>sleep_until</code>.</li> <li>Ajustes r\u00e1pidos: cambiar <code>SAMPLES_PER_CYCLE</code> mejora la suavidad (m\u00e1s muestras) a costa de mayor tasa de actualizaci\u00f3n.</li> </ul>"},{"location":"practicas/temporizadores/comparativa/","title":"Comparativa de codigos optimizados","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"practicas/temporizadores/comparativa/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Blink con temporizador (alto y bajo nivel) en Raspberry Pi Pico  </li> <li>Autor: Antonio Martinez </li> <li>Curso / Asignatura: Sistemas Embebidos </li> <li>Fecha: 10/09/2025 </li> <li>Descripci\u00f3n breve: Implementaci\u00f3n y comparaci\u00f3n de dos enfoques para parpadear un LED en la Raspberry Pi Pico: (1) SDK de alto nivel con <code>add_repeating_timer_ms</code> y (2) bajo nivel programando ALARM0 e IRQ del perif\u00e9rico TIMER.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"practicas/temporizadores/comparativa/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Evaluar precisi\u00f3n, simplicidad y control de dos m\u00e9todos de temporizaci\u00f3n (alto vs. bajo nivel) para el parpadeo de un LED en la Pico.</li> <li>Espec\u00edficos:</li> <li>Implementar un parpadeo con timer de alto nivel (SDK).</li> <li>Implementar un parpadeo con timer de sistema + ALARM0 + IRQ.</li> <li>Comparar periodo efectivo y estabilidad de ambos enfoques mediante mediciones/observaciones.</li> <li>Documentar configuraci\u00f3n, c\u00f3digo y resultados.</li> </ul>"},{"location":"practicas/temporizadores/comparativa/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye:</li> <li>C\u00f3digo C para Pico (RP2040/RP2350).</li> <li>Explicaciones de configuraci\u00f3n GPIO y temporizadores.</li> <li>F\u00f3rmulas de periodo/frecuencia y tabla de par\u00e1metros.</li> <li> <p>Secciones para insertar capturas/mediciones.</p> </li> <li> <p>No incluye:</p> </li> <li>Medidas con instrumentos espec\u00edficos (osciloscopio/analizador l\u00f3gico) (pueden anexarse como evidencia).</li> <li>Optimizaci\u00f3n avanzada de latencia fuera del alcance did\u00e1ctico.</li> </ul>"},{"location":"practicas/temporizadores/comparativa/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Pico SDK (v1.x\u2013v2.x) - CMake (\u2265 3.13) - Toolchain GCC ARM (ej. <code>arm-none-eabi-gcc</code>) - <code>picotool</code> (opcional, para flasheo) - Git</p> <p>Hardware - Raspberry Pi Pico / Pico 2 (RP2040/RP2350) - LED en GP15 (si tu placa no trae LED en ese pin) + resistencia (220\u20131k\u03a9) - Osiloscopio</p> <p>Conocimientos previos - C b\u00e1sico - Electr\u00f3nica digital b\u00e1sica (GPIO, resistencias) - Flujo de compilaci\u00f3n con Pico SDK</p>"},{"location":"practicas/temporizadores/comparativa/#5-codigo-1-y-resultados","title":"5) Codigo 1 y resultados","text":"<pre><code>// Blink con timer (SDK alto nivel): cambia BLINK_MS para ajustar\n#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 15              // &lt;-- usar GPIO 15 (GP15)\nstatic const int BLINK_MS = 250;\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true;\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);  // mejor usar GPIO_OUT que true\n\n    repeating_timer_t timer;\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>Resultados </p>"},{"location":"practicas/temporizadores/comparativa/#6-codigo-2-y-resultados","title":"6) Codigo 2 y resultados","text":"<pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN 15    \n#define ALARM_NUM     0  // usaremos la alarma 0\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 250000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre> <p>Resultados </p>"},{"location":"practicas/temporizadores/comparativa/#7-comparativa-y-conclusiones","title":"7) Comparativa y conclusiones","text":"<p>Resumen de la medici\u00f3n. Con ambos programas configurados para conmutar cada 250 ms, se observ\u00f3 una diferencia de 0.1 ms a favor del enfoque de bajo nivel (ALARM0 + IRQ), es decir, el de bajo nivel fue ligeramente m\u00e1s r\u00e1pido.</p> M\u00e9todo (T_{\\text{toggle}}) medido Desviaci\u00f3n vs 250 ms Comentario breve Alto nivel (repeating_timer) 250.1 ms +0.1 ms Despacho mediante callback del SDK Bajo nivel (ALARM0 + IRQ) 250.0 ms 0.0 ms Programaci\u00f3n directa de alarma + <code>sio_hw-&gt;gpio_togl</code> <p>Interpretaci\u00f3n. - El alto nivel introduce una peque\u00f1a latencia por la capa de abstracci\u00f3n (gesti\u00f3n del callback, comprobaciones internas), lo que explica el retardo adicional de ~0.1 ms. - El bajo nivel programa el \u201cdeadline\u201d en el temporizador de hardware y conmuta el pin v\u00eda SIO (<code>sio_hw-&gt;gpio_togl</code>) dentro de la ISR, reduciendo el overhead y la deriva acumulada.</p> <p>Conclusiones pr\u00e1cticas. - Para aplicaciones did\u00e1cticas o de prototipado, el enfoque alto nivel es suficiente y m\u00e1s legible. - Para requisitos de precisi\u00f3n temporal o ventanas largas (minimizando deriva/jitter), el enfoque bajo nivel es preferible. - Aunque la diferencia medida (0.1 ms) es peque\u00f1a, confirma que la ruta ALARM0 + IRQ ofrece mejor control temporal con el mismo par\u00e1metro nominal.</p> <p>Notas de medici\u00f3n. - Asegurar condiciones comparables (misma alimentaci\u00f3n, misma carga en el pin y entorno) y, si es posible, repetir varias veces y reportar promedio y desviaci\u00f3n. - El contador de 32 bits del TIMER \u201cenvuelve\u201d ~cada 71.6 min; el uso de deadline acumulativo mantiene el ritmo al pasar por el wrap-around.</p>"},{"location":"practicas/temporizadores/temporizadores/","title":"-control de LEDs","text":""},{"location":"practicas/temporizadores/temporizadores/#parpadeo-de-4-leds-con-system-timer-rp2350-pico-2","title":"Parpadeo de 4 LEDs con System Timer (RP2350 / Pico 2)","text":"<p>Resumen</p> <p>Este programa usa las 4 hardware alarms del temporizador de sistema para hacer parpadear 4 LEDs de manera independiente, programando cada pr\u00f3ximo \u201cdeadline\u201d en microsegundos dentro de cada ISR (interrupt service routine). Es un enfoque sin bloqueo: todo el parpadeo ocurre en las ISRs; el <code>while(true)</code> queda libre.</p>"},{"location":"practicas/temporizadores/temporizadores/#objetivo","title":"Objetivo","text":"<ul> <li>Controlar 4 LEDs con periodos distintos usando ALARM0..ALARM3 del perif\u00e9rico <code>timer</code>.</li> <li>Trabajar en microsegundos (timebase de 1 MHz).</li> <li>Mantener precisi\u00f3n temporal reprogramando el siguiente disparo desde el deadline previo (evita drift).</li> </ul>"},{"location":"practicas/temporizadores/temporizadores/#plataforma-y-dependencias","title":"Plataforma y dependencias","text":"<ul> <li>MCU: RP2350 (Raspberry Pi Pico 2)  </li> <li>SDK: Raspberry Pi Pico SDK  </li> <li>Headers: <code>pico/stdlib.h</code>, <code>hardware/irq.h</code>, <code>hardware/structs/timer.h</code>, <code>hardware/gpio.h</code></li> </ul>"},{"location":"practicas/temporizadores/temporizadores/#mapa-de-pines-y-alarmas","title":"Mapa de pines y alarmas","text":"Recurso Definici\u00f3n Uso en c\u00f3digo LED0 <code>LED0_PIN = 12</code> Parpadeo con ALARM0 LED1 <code>LED1_PIN = 13</code> Parpadeo con ALARM1 LED2 <code>LED2_PIN = 14</code> Parpadeo con ALARM2 LED3 <code>LED3_PIN = 15</code> Parpadeo con ALARM3 ALARM0 <code>ALARM0_NUM = 0</code> IRQ <code>ALARM0_IRQ</code> \u2192 <code>on_alarm0_irq()</code> ALARM1 <code>ALARM1_NUM = 1</code> IRQ <code>ALARM1_IRQ</code> \u2192 <code>on_alarm1_irq()</code> ALARM2 <code>ALARM2_NUM = 2</code> IRQ <code>ALARM2_IRQ</code> \u2192 <code>on_alarm2_irq()</code> ALARM3 <code>ALARM3_NUM = 3</code> IRQ <code>ALARM3_IRQ</code> \u2192 <code>on_alarm3_irq()</code> <p>Nota: Asegura que los comentarios de pines coinciden con los <code>#define</code> usados.</p>"},{"location":"practicas/temporizadores/temporizadores/#periodos-y-frecuencias","title":"Periodos y frecuencias","text":"<p>Los intervalos est\u00e1n en \u00b5s:</p> <ul> <li><code>INTERVALO0_US = 250000</code> \u2192 0.25 s \u2192 4 Hz</li> <li><code>INTERVALO1_US = 500000</code> \u2192 0.50 s \u2192 2 Hz</li> <li><code>INTERVALO2_US = 750000</code> \u2192 0.75 s \u2192 1.33 Hz</li> <li><code>INTERVALO3_US = 1000000</code> \u2192 1.00 s \u2192 1 Hz</li> </ul> <p>Cambia estas constantes para ajustar la velocidad de cada LED.</p>"},{"location":"practicas/temporizadores/temporizadores/#flujo-de-ejecucion","title":"Flujo de ejecuci\u00f3n","text":"<ol> <li>Inicializaci\u00f3n de GPIOs: <code>gpio_init()</code>, <code>gpio_set_dir(..., GPIO_OUT)</code> y <code>gpio_put(..., 0)</code> por LED.  </li> <li>Base de tiempo: <code>timer_hw-&gt;source = 0u;</code> (1 MHz \u2192 1 \u00b5s por tick).  </li> <li>Captura \u201cahora\u201d: <code>now_us = timer_hw-&gt;timerawl;</code> (32 bits bajos).  </li> <li>Deadlines iniciales: <code>nextX_us = now_us + INTERVALOX_US</code> (X=0..3).  </li> <li>Programaci\u00f3n de alarmas: <code>timer_hw-&gt;alarm[ALARMX_NUM] = nextX_us</code>.  </li> <li>ISRs registradas y IRQs habilitadas.  </li> <li>Bucle principal: <code>tight_loop_contents();</code> (sin trabajo, todo ocurre en ISRs).</li> </ol>"},{"location":"practicas/temporizadores/temporizadores/#rutinas-de-interrupcion-isrs","title":"Rutinas de interrupci\u00f3n (ISRs)","text":"<p>Cada ISR:</p> <ul> <li>Limpia su flag: <code>hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARMX_NUM);</code></li> <li>Conmuta el pin: <code>sio_hw-&gt;gpio_togl = 1u &lt;&lt; LEDX_PIN;</code></li> <li>Reagenda desde el deadline: <code>nextX_us += INTERVALOX_US;</code></li> <li>Reprograma su alarma: <code>timer_hw-&gt;alarm[ALARMX_NUM] = nextX_us;</code></li> </ul> <p>Reagendar desde el deadline previo evita el drift que ocurrir\u00eda si se usara el \u201ctiempo actual\u201d.</p>"},{"location":"practicas/temporizadores/temporizadores/#consideraciones-de-temporizacion","title":"Consideraciones de temporizaci\u00f3n","text":"<ul> <li>Rollover 32 bit: <code>timerawl</code>/<code>nextX_us</code> envuelven cada \u2248 71.58 min (2^32 \u00b5s). El esquema por deadlines lo maneja bien si todo se mantiene en 32 bits.  </li> <li>SIO toggle: Requiere GPIO en funci\u00f3n SIO (por defecto tras <code>gpio_init()</code>). Es at\u00f3mico y r\u00e1pido.  </li> <li>ISRs ligeras: Evita trabajo pesado dentro de interrupciones.</li> </ul>"},{"location":"practicas/temporizadores/temporizadores/#codigo","title":"codigo","text":"<pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     12   // LED integrado\n#define LED1_PIN     13                      // LED externo en GPIO 0\n#define LED2_PIN     14   // LED integrado\n#define LED3_PIN     15\n\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n#define ALARM3_NUM   3\n\n\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n#define ALARM3_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM3_NUM)\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us,next2_us,next3_us;\nstatic const uint32_t INTERVALO0_US = 250000u;\nstatic const uint32_t INTERVALO1_US = 500000u;\nstatic const uint32_t INTERVALO2_US = 750000u;\nstatic const uint32_t INTERVALO3_US = 1000000u;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\nstatic void on_alarm3_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM3_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED3_PIN;\n    next3_us += INTERVALO3_US;\n    timer_hw-&gt;alarm[ALARM3_NUM] = next3_us;\n}\n\n\n\n\nint main() {\n\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n\n    gpio_init(LED3_PIN);\n    gpio_set_dir(LED3_PIN, GPIO_OUT);\n    gpio_put(LED3_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n    next3_us = now_us + INTERVALO3_US;\n\n    // Programa ambas alarmas\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next2_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next3_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n    irq_set_exclusive_handler(ALARM3_IRQ, on_alarm3_irq);\n\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM) | (1u &lt;&lt; ALARM3_NUM));\n\n    // Habilita ambas IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n    irq_set_enabled(ALARM3_IRQ, true);\n\n    // Bucle principal: todo el parpadeo ocurre en las ISRs\n    while (true) {\n        tight_loop_contents();\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre>"}]}